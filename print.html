<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lockjaw User Guide</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="before.html">Before using</a></li><li class="chapter-item expanded affix "><a href="glossary.html">Glossary</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.</strong> Project Setup</a></li><li class="chapter-item expanded "><a href="inject.html"><strong aria-hidden="true">2.</strong> Injecting Objects</a></li><li class="chapter-item expanded "><a href="request.html"><strong aria-hidden="true">3.</strong> Requesting Objects</a></li><li class="chapter-item expanded "><a href="provides.html"><strong aria-hidden="true">4.</strong> Providing Objects</a></li><li class="chapter-item expanded "><a href="builder.html"><strong aria-hidden="true">5.</strong> Builder Modules</a></li><li class="chapter-item expanded "><a href="binds.html"><strong aria-hidden="true">6.</strong> Binding traits</a></li><li class="chapter-item expanded "><a href="scoped.html"><strong aria-hidden="true">7.</strong> Scoped Bindings</a></li><li class="chapter-item expanded "><a href="qualifiers.html"><strong aria-hidden="true">8.</strong> Qualifiers</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="provider.html"><strong aria-hidden="true">9.</strong> Provider</a></li><li class="chapter-item expanded "><a href="lazy.html"><strong aria-hidden="true">10.</strong> Lazy</a></li><li class="chapter-item expanded "><a href="factory.html"><strong aria-hidden="true">11.</strong> Factory</a></li><li class="chapter-item expanded "><a href="optional.html"><strong aria-hidden="true">12.</strong> Optional Bindings</a></li><li class="chapter-item expanded "><a href="multibindings.html"><strong aria-hidden="true">13.</strong> Multibindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vec.html"><strong aria-hidden="true">13.1.</strong> Vec bindings</a></li><li class="chapter-item expanded "><a href="map.html"><strong aria-hidden="true">13.2.</strong> Map bindings</a></li><li class="chapter-item expanded "><a href="empty_multibinding.html"><strong aria-hidden="true">13.3.</strong> Empty multibindings</a></li></ol></li><li class="chapter-item expanded "><a href="subcomponent.html"><strong aria-hidden="true">14.</strong> Subcomponents</a></li><li class="chapter-item expanded "><a href="define_component.html"><strong aria-hidden="true">15.</strong> Defined components</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="caveats.html"><strong aria-hidden="true">16.</strong> Caveats</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="code-of-conduct.html">Code of conduct</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Lockjaw User Guide</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Lockjaw is a fully static, compile-time
<a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> framework for
<a href="https://www.rust-lang.org/">Rust</a> inspired by <a href="https://dagger.dev">Dagger</a>.</p>
<h2 id="why-use-a-dependency-injection-framework"><a class="header" href="#why-use-a-dependency-injection-framework">Why use a dependency injection framework</a></h2>
<p>The main purpose of dependency injection is to separate the concerns of creating an object and using
an object. In larger projects creating an object soon becomes a complicated process since creating
an object ofter requires other objects that needs to be created fist(a dependency). Once the object
dependency graph grows deep and wide adding a new edge or node becomes a painful endeavor. For
example, you may need to modify the signature of a dozen methods and interfaces just to pass the new
object all the way to the site it is actually going to be used. This often ends up with
anti-patterns like god objects and global states holding objects so the path can be shortened.</p>
<p>The dependency injection <em>technique</em> alleviates this problem by making an object only receive the
objects they need. The object no longer needs to know what is required to create those objects, nor
will have any change if their indirect dependency changes. Responsibility for creating objects is
moved to factories.</p>
<p>A dependency injection <em>framework</em> further manages this by automating the creation of the factories.
Users simply specify what each object needs, which implementation to use for an interface, etc., and
the objects can be created.</p>
<h2 id="why-use-lockjaw-as-the-dependency-injection-framework"><a class="header" href="#why-use-lockjaw-as-the-dependency-injection-framework">Why use Lockjaw as the dependency injection framework</a></h2>
<p>Lockjaw is inspired by <a href="https://dagger.dev">Dagger</a>, which is a mature dependency injection
framework for Java. Lockjaw has feature parity with Dagger (
sans <a href="https://dagger.dev/dev-guide/producers">producers</a>, which may not be too useful in Rust with
async/await available.)</p>
<p>Main features:</p>
<ul>
<li>Compile time dependency resolution
<ul>
<li>Lockjaw makes sure all dependencies are fulfilled at compile time. The code will fail to
compile if a dependency is missing, there are duplicated bindings for the same type, or if the
dependency graph has cycles. There will be no runtime errors which are harder to detect.</li>
</ul>
</li>
<li>Cross-crate injection
<ul>
<li>Lockjaw is designed to be used across crates. Clients are able to inject bindings provided by
libraries if they also use Lockjaw.</li>
</ul>
</li>
<li>Minimal generated code surface
<ul>
<li>While procedural macros are utilized heavily by Lockjaw, it avoids directly modifying the code
the attributes macros are placed on. Only a few generated methods are visible to the user.
This is especially important since most Rust IDEs today does not understand the output of
procedural macros, a few extra type hints on <code>let</code> expressions is enough to make autocomplete
functional.</li>
</ul>
</li>
<li>Optional binding, Multibinding, and generated components for plugin systems
<ul>
<li>Lockjaw allows <a href="https://en.wikipedia.org/wiki/Inversion_of_control">inversion of control</a>
between library crates and their user. A library is able to define hooks for clients that
depends on the library to inject. This is especially useful to test multiple clients using a
library in isolation.</li>
</ul>
</li>
</ul>
<h2 id="why-not-use-lockjaw-as-the-dependency-injection-framework"><a class="header" href="#why-not-use-lockjaw-as-the-dependency-injection-framework">Why <em>NOT</em> use Lockjaw as the dependency injection framework</a></h2>
<p>While the generated code generally is OK-ish, abhorrent techniques are used to generate the code
under the confinement of the current Rust proc-macro system and is extremely fragile.</p>
<p>Please read the <a href="before.html">before using</a> chapter before using Lockjaw. Lockjaw currently cannot be
recommended for serious work in good conscious. <strong>YOU HAVE BEEN WARNED</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="before-using-lockjaw"><a class="header" href="#before-using-lockjaw">Before Using Lockjaw</a></h1>
<p>Before using lockjaw you should carefully consider if it is really for you. Having compile time
dependency injection is wonderful, but the current Rust proc-macro system does not make it easy, and
there are a lot of trade-offs.</p>
<h2 id="robustness"><a class="header" href="#robustness">Robustness</a></h2>
<p>Lockjaw is experimental in its nature, with the main goal of reaching feature parity with Dagger. It
tries to answer:</p>
<ul>
<li>What dependency injection would look like in Rust?
<ul>
<li>Is it even possible?</li>
<li>Is it going to be useful?</li>
<li>How should lifetimes and borrows be handled?</li>
</ul>
</li>
<li>What are the hurdles when trying to implement a dependency injection framework in Rust?</li>
</ul>
<p>Currently lockjaw focuses on &quot;can&quot; instead of &quot;should&quot;. If there is any hacky undocumented compiler
behavior we can abuse to implement a feature, It <strong>will</strong> be used. While we try to make it bug-free
and generate safe code in the current version of Rust, there are no guarantee it will continue to
work in the future.</p>
<p>See the <a href="caveats.html">caveats</a> section for all horrible hacks used.</p>
<p>Future efforts might be made to get language features Lockjaw need implemented in Rust, but that is
a very long road.</p>
<h2 id="maintenance"><a class="header" href="#maintenance">Maintenance</a></h2>
<p>Lockjaw is a quite complicated project, but it is built by the developer with short attention span
and other priorities, as a hobby project, while also trying to learn Rust. Do not expect continuous
support, and especially consider that newer Rust can break Lockjaw at any moment.</p>
<h2 id="irreversibility"><a class="header" href="#irreversibility">Irreversibility</a></h2>
<p>Dependency injection frameworks are very invasive and will change how code are written. If you
decide to remove Lockjaw in the future, you may need to rewrite the whole project.</p>
<h2 id="only-use-lockjaw-if"><a class="header" href="#only-use-lockjaw-if">Only use lockjaw if...</a></h2>
<ul>
<li>You also like to live dangerously.</li>
<li>You are experimenting things.</li>
<li>You are working on a small project, and it won't be maintained in the future.</li>
<li>Someone else will be maintaining the project in the future, and you are a horrible individual.</li>
<li>You love dependency injection so much you are willing to patch bugs yourself, and freeze Rust
version if it breaks Lockjaw.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="module"><a class="header" href="#module">Module</a></h2>
<p>In all Lockjaw documentations, &quot;module&quot; refers to a <em>dependency injection module</em>. When referring to
Rust modules <code>mod</code> will be used instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>Add lockjaw to the <code>[dependencies]</code> and <code>[build_dependencies]</code> section of your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
lockjaw = &quot;*&quot;

[build-dependencies]
lockjaw = &quot;*&quot;
</code></pre>
<p>The proc_macro and runtime library are packaged into the same crate, so this is the only target you
need.</p>
<h2 id="build-script"><a class="header" href="#build-script">Build script</a></h2>
<p>Lockjaw also needs some environment setup, and requires a
<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a>. Add <code>build.rs</code> next to
<code>Cargo.toml</code>, and
call <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/fn.build_script.html"><code>lockjaw::build_script()</code></a>
in <code>main()</code> inside it:</p>
<pre><code class="language-rust no_run noplayground">// https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/build.rs
fn main() {
    lockjaw::build_script();
}
</code></pre>
<p>Lockjaw will ask you to do this if this step is missing.</p>
<h2 id="prologue-macro"><a class="header" href="#prologue-macro">Prologue macro</a></h2>
<p>Before using any Lockjaw attribute macros, the
lockjaw <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/macro.prologue.html"><code>prologue!()</code></a> macro must be
called:</p>
<pre><code class="language-rust no_run noplayground">// https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/src/main.rs
lockjaw::prologue!(&quot;src/main.rs&quot;);
</code></pre>
<p>The file path of the current source file should be passed to the prologue.</p>
<p>Lockjaw need to perform some static analysis on the current source file to understand type names,
which is an integral part of a dependency injection framework. If a type is encountered, what is its
fully qualified name? Is it something imported with a <code>use</code> declaration? or if it is a locally
declared, what is the <code>mod</code> path to the local scope?</p>
<p>Lockjaw also generates a test to verify the source path is correct. However passing a wrong path
often result in weird type resolution errors at compile time. Double-check the source path if there
are type resolution issues.</p>
<h2 id="epilogue-macro"><a class="header" href="#epilogue-macro">Epilogue macro</a></h2>
<p>You also must call
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/macro.epilogue.html"><code>lockjaw::epilogue!()</code></a> macro in the
root of your crate (<code>lib.rs</code> or
<code>main.rs</code>) after all other uses of lockjaw, preferably at the end of the file.</p>
<pre><code class="language-rust no_run noplayground">// https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/src/main.rs
lockjaw::epilogue!();
</code></pre>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/">Source</a> of this chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="injecting-objects"><a class="header" href="#injecting-objects">Injecting Objects</a></h1>
<p>Lockjaw can create objects for you, but you need to let lockjaw know how to create the object and
what is needed to create them. These recipes for object creation is called <em>bindings</em>, which forms
nodes in a dependency graph, and add edges to other bindings it depends on.</p>
<p>The most simple binding is constructor injection binding.</p>
<h2 id="constructor-injection"><a class="header" href="#constructor-injection">Constructor injection</a></h2>
<p>A binding can be created for a struct by using a constructor method, which is a static method
associated to the struct that returns a new instance. The field constructor ( <code>Foo {a : 0, ...}</code>) is
not directly used by Lockjaw since methods are more expressive when a none injected field needs a
default value or when transformations are needed on the input.</p>
<p>A struct can be made injectable by marking a struct <code>impl</code> block with
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.injectable.html"><code>#[injectable]</code></a> attribute, and
then mark the constructor method
as <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a>.</p>
<pre><code class="language-rust no_run noplayground">struct Foo {}

#[injectable]
impl Foo {
    #[inject]
    pub fn new() -&gt; Foo {
        Foo {}
    }
}
</code></pre>
<p>Now Lockjaw understands when trying to create <code>Foo</code>, it should call <code>Foo::new()</code>.</p>
<p>Note that since it is an associated method, constructor injection only works on a type you <em>own</em> (
you can actually change its implementation). For foreign types like imported crates a different
method will be discussed in the <a href="provides.html">providing objects</a> chapter.</p>
<h2 id="constructor-dependencies"><a class="header" href="#constructor-dependencies">Constructor dependencies</a></h2>
<p>To create an object, it may many need objects of other types. This is called <em>dependencies</em>. In this
example, <code>Bar</code> <em>depends</em> on having an instance of <code>Foo</code> to be created.</p>
<p>In constructor injections, dependencies are listed with its parameters. Lockjaw will try to use
available bindings to create all arguments and pass them to the constructor. If a parameter does not
have a binding, Lockjaw will fail compilation with <em>missing bindings</em>.</p>
<p>Note that since we are not asking Lockjaw to actually create the object yet, binding validation
won't be performed. Lockjaw is assuming there are some bindings else where it does not know about
yet.</p>
<pre><code class="language-rust no_run noplayground">struct Bar {
    foo: Foo,
    i: i32,
}

#[injectable]
impl Bar {
    #[inject]
    pub fn new(foo: Foo) -&gt; Bar {
        Bar { foo, i: 42 }
    }
}
</code></pre>
<p>If the struct has other fields that can be initialized without injection, like <code>i</code>, it can be
directly assigned. If the object needs a runtime value (for example, if <code>i</code> needs to be assigned by
the caller with a user input), then <a href="factory.html">factories</a> will be needed, which will be discussed
later.</p>
<h2 id="manual-injection"><a class="header" href="#manual-injection">Manual injection</a></h2>
<p>For a moment let's forget about Lockjaw, and try to do dependency injection manually. With the
binding information we have we can write a factory that can create the objects we just defined:</p>
<pre><code class="language-rust no_run noplayground">struct Factory {}

impl Factory {
    pub fn create_foo(&amp;self) -&gt; Foo {
        Foo::new()
    }

    pub fn create_bar(&amp;self) -&gt; Bar {
        Bar::new(self.create_foo())
    }
}

#[test]
fn test() {
    let factory = Factory {};

    let _foo = factory.create_foo();
    let _bar = factory.create_bar();
}
</code></pre>
<p>Note that there is one method for each binding, only taking <code>&amp;self</code> and returning the binding type.
Inside the method it calls the constructor method we just marked, and calls other binding methods to
generate the argument.</p>
<p>The factory is an object instead of just methods, since it might need to carry states in the future
(For example, returning a reference to a shared object owned by the factory.)</p>
<p>Writing the factory by hand gets complicated and boring fast. In the next chapter we will ask
Lockjaw to generate it.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/inject/">Source</a> of this chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requesting-objects"><a class="header" href="#requesting-objects">Requesting objects</a></h1>
<p>In the last chapter we manually wrote an object factory:</p>
<pre><code class="language-rust no_run noplayground">struct Factory {}

impl Factory {
    pub fn create_foo(&amp;self) -&gt; Foo {
        Foo::new()
    }

    pub fn create_bar(&amp;self) -&gt; Bar {
        Bar::new(self.create_foo())
    }
}

#[test]
fn test() {
    let factory = Factory {};

    let _foo = factory.create_foo();
    let _bar = factory.create_bar();
}
</code></pre>
<p>Now we will ask Lockjaw to automatically generate it. A factory generating objects using a certain
dependency graph is called a <code>Component</code> in Dagger terminology.</p>
<h2 id="defining-the-component"><a class="header" href="#defining-the-component">Defining the component</a></h2>
<pre><code class="language-rust no_run noplayground">#[component]
trait MyComponent {
    fn create_foo(&amp;self) -&gt; Foo;

    fn create_bar(&amp;self) -&gt; Bar;
}
</code></pre>
<p>Comparing to the manual factory there are not a lot of changes. Since Lockjaw Cannot generate the
implementation immediately, we use a <code>trait</code> instead of a <code>struct</code> as the interface has to be
abstract. The <code>trait</code> is then annotated with
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html"><code>#[component]</code></a> attribute that
instructs Lockjaw to generate the implementation. Lockjaw is able to identify
all <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a>
bindings automatically.</p>
<p>For every type we wish to be able to directly create from the component, a method returning the type
should be added to the <code>trait</code>. Like the manual factory, the method should take <code>&amp;self</code> (and nothing
else) so it may further use the component to create the dependencies it needs. The name of the
method does not really matter, but since you are going to call it later you'd probably want
something sensible.</p>
<p>Note that if a type is not directly needed, the <code>trait</code> does not need a method for it. For example
while <code>Bar</code> needs <code>Foo</code>, if we are never going to use <code>Foo</code> in <code>main()</code> we can delete the
<code>create_foo()</code> method. The trait methods does not affect Lockjaw internal generation, it only
declares what needs to be publicly provided.</p>
<h2 id="creating-and-using-the-component"><a class="header" href="#creating-and-using-the-component">Creating and using the component.</a></h2>
<p>Since <code>create_foo(&amp;self)</code> is a method, we need to create the component to be able to call it.
Lockjaw generates a static <code>build()</code> method on the trait that can be used to create the component.</p>
<pre><code class="language-rust no_run noplayground">#[test]
fn test() {
    let component: Box&lt;dyn MyComponent&gt; = &lt;dyn MyComponent&gt;::build();

    let _foo = component.create_foo();
    let _bar = component.create_bar();
}
</code></pre>
<p><code>build()</code> returns <code>Box&lt;dyn COMPONENT&gt;</code>. Most IDE today does not understand symbols generated by
procedural macros, so you might want to manually hint the type in the <code>let</code> expression.</p>
<p>Once the component is created, the trait methods can be used to create the objects.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/request/">Source</a> of this
chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="providing-objects"><a class="header" href="#providing-objects">Providing Objects</a></h2>
<p>In this chapter we will discuss another way to create bindings.</p>
<h2 id="limitations-of-constructor-injection-bindings"><a class="header" href="#limitations-of-constructor-injection-bindings">Limitations of constructor injection bindings</a></h2>
<p>Constructor injections are designed to be the <strong>only</strong> way to create an instance of the type it
binds. It is even considered bad practice to call the constructor manually. Hence, constructor
injections has some limitations:</p>
<ul>
<li>Constructor injections can only be done by owned types (can only be defined by the <code>mod</code> that
defines the type itself.).
<ul>
<li>If you don't own the type you should not say something is the only way to create it.</li>
</ul>
</li>
<li>Can only create concrete types
<ul>
<li>Sometimes you may want to bind traits and swap the implementation, maybe at runtime.</li>
</ul>
</li>
</ul>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Obviously Lockjaw is not going to ask the world to use it or the user to rewrite everything they use
with it, so it gives other ways to bind types. Since these bindings are no longer the &quot;one true way
to create things&quot;, and different bindings for the same type may be needed within the same program,
the user needs to be able to select which bindings to use in each dependency graph.</p>
<p>In Lockjaw, these elective bindings are defined in <em>modules</em>, and the component can choose what
modules to <em>install</em>, which imports its bindings. Note that in Lockjaw documentation <em>modules</em>
always refer dependency injection modules, and <code>mod</code> will be used to refer to Rust modules.</p>
<p>To declare a module with Lockjaw
the <a href="file:///C:/git/lockjaw/target/doc/lockjaw/attr.module.html"><code>#[module]</code></a> attribute should be
used to mark the <code>impl</code> block of a struct.</p>
<pre><code class="language-rust no_run noplayground">struct MyModule {}

#[module]
impl My Module {
  ...
}
</code></pre>
<p>The <code>impl</code> block will contain the binding definitions.</p>
<p>For now the modules should be static (without fields). Modules with fields will be discussed
in <a href="builder.html">builder modules</a></p>
<h2 id="provides-bindings"><a class="header" href="#provides-bindings">#[provides] bindings</a></h2>
<p>The <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a>
binding annotates a method that returns the type.</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    pub fn provide_i32() -&gt; i32 {
        42
    }
</code></pre>
<p>Like <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a>,
the <code>#[provides]</code> method can also request other bindings from the dependency graph, and produce the
target value with it.</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    pub fn provides_string(i: i32) -&gt; String {
        format!(&quot;{}&quot;, i)
    }
</code></pre>
<h2 id="installing-modules"><a class="header" href="#installing-modules">Installing modules</a></h2>
<p><code>#[module]</code> on its own is just a collection of bindings and does not do anything. It must be
installed in a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html"><code>#[component]</code></a> to joint
the dependency graph. This is done by listing the module type in
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html#modules"><code>modules</code> metadata</a> of the
component.</p>
<pre><code class="language-rust no_run noplayground">#[component(modules: [MyModule])]
trait MyComponent {
    fn i32(&amp;self) -&gt; i32;

    fn string(&amp;self) -&gt; String;
}
</code></pre>
<p>A lot of Lockjaw attribute macros also takes <em>metadata arguments</em>, which is comma
separated <code>key : value</code> pairs in a parenthesis. The values are usually string literal, integers,
types, arrays of values (<code>foo : [value 1, value 2]</code>), or more metadata (<code>foo : { key : value }</code>). In
this case <code>modules</code> takes an array of types (of <code>#[modules]</code>).</p>
<p>Providing <code>trait</code> is a bit more complicated and will be discussed <a href="binds.html">later</a>.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/provide/">Source</a> of this
chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builder-modules"><a class="header" href="#builder-modules">Builder Modules</a></h1>
<p>In the previous chapter the modules are without fields, so Lockjaw can easily create instances of it
(In fact no instance are created since Lockjaw can just call the static methods). However sometimes
we want to be able to affect the values that are bound at runtime, hence need to be able to change
what <code>#[provides]</code> does using fields in the module.</p>
<pre><code class="language-rust no_run noplayground">struct MyModule {
    i: i32,
}

#[module]
impl MyModule {
    #[provides]
    pub fn provide_i32(&amp;self) -&gt; i32 {
        self.i
    }
}
</code></pre>
<p>Since the <code>struct</code> now has fields Lockjaw can no longer automatically create it, the user must
manually pass in the modules when creating the component.</p>
<p><em>Implementation note: While Lockjaw can also try to
use <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a> or some other mechanisms,
usages like this implies the module has mutable state and generally is a bad idea.</em></p>
<h2 id="using-builder-modules"><a class="header" href="#using-builder-modules">Using builder modules</a></h2>
<p>Instead of passing the runtime modules to the component one by one, they are collected in a single
<code>struct</code> annotated by
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.builder_modules.html"><code>#[builder_modules]</code></a>
attribute.</p>
<pre><code class="language-rust no_run noplayground">#[builder_modules]
struct MyBuilderModules {
    my_module: MyModule,
}
</code></pre>
<p>Every field in the struct should be a module. Using a <code>struct</code> makes sure each module will be
required by the compiler/IDE while exposing the least amount of generated code(which is harder for
users and IDEs to understand, it is better to spell everything out in visible code.).</p>
<p>The <code>#[builder_modules]</code> can then be installed in the component using
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html#builder_modules"><code>builder_modules</code> metadata</a></p>
<pre><code class="language-rust no_run noplayground">#[component(builder_modules: MyBuilderModules)]
trait MyComponent {
    fn i32(&amp;self) -&gt; i32;
}
</code></pre>
<p>The component only accepts one<code>#[builder_modules]</code>, which is likely to be specifically tailored for
the component. The modules itself can be shared.</p>
<p>The <code>builder_modules</code> metadata can be used at the same time with
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html#modules"><code>modules</code> metadata</a>.
<code>modules</code> should be preferred whenever possible as they are easier to use.</p>
<h2 id="creating-components-with-builder-modules"><a class="header" href="#creating-components-with-builder-modules">Creating components with builder modules</a></h2>
<p>If
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html#builder_modules"><code>builder_modules</code> metadata</a>
is specified,
the  <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.builder_modules.html"><code>#[builder_modules] struct</code></a>
will become the parameter for
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html#component-builder"><code>build()</code> method</a>
of the component which the user must pass.</p>
<pre><code class="language-rust no_run noplayground">#[test]
fn test() {
    let my_module = MyModule { i: 42 };
    let my_builder_modules = MyBuilderModules { my_module };
    let component: Box&lt;dyn MyComponent&gt; = &lt;dyn MyComponent&gt;::build(my_builder_modules);
    assert_eq!(component.i32(), 42);

    let other_component: Box&lt;dyn MyComponent&gt; = &lt;dyn MyComponent&gt;::build(MyBuilderModules {
        my_module: MyModule { i: 123 },
    });
    assert_eq!(other_component.i32(), 123);
}
</code></pre>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/builder/">Source</a> of this
chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-traits"><a class="header" href="#binding-traits">Binding traits</a></h1>
<h2 id="provides-trait"><a class="header" href="#provides-trait"><code>#[provides]</code> trait</a></h2>
<p>A <code>trait</code> can be provided using
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a>
binding.</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    pub fn provide_i32_maker(impl_: I32MakerImpl) -&gt; Box&lt;dyn I32Maker&gt; {
        Box::new(impl_)
    }
</code></pre>
<p>However, Lockjaw is going to be particular when trying to request a trait object from the dependency
graph. The concrete implementation of the trait may contain <a href="scoped.html">reference to the component</a>,
but ideally this is not something the consumer of the trait should care about, so Lockjaw enforces
that any trait it provides must not outlive the component. The worst case <code>'ComponentLifetime</code> is
assumed, so consumers don't have to change when it actually happens.</p>
<p>The <code>Box</code> returned by the component must be bound by the component's lifetime(same as <code>self</code>).</p>
<pre><code class="language-rust no_run noplayground">#[component(modules: [MyModule])]
trait ProvideComponent {
    fn i32_maker(&amp;'_ self) -&gt; Box&lt;dyn I32Maker + '_&gt;;
}
</code></pre>
<h2 id="binds-trait"><a class="header" href="#binds-trait"><code>#[binds]</code> trait</a></h2>
<p>While <code>#[provides]</code> kind of works, binding an implementation to a <code>trait</code> interface is a common
operation so Lockjaw has
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.binds.html"><code>#[binds]</code></a> attribute
to make them easier to use.</p>
<p>For an interface and an implementation:</p>
<pre><code class="language-rust no_run noplayground">pub trait Logger {
    fn log(&amp;self, msg: &amp;str);
}

struct StdoutLogger;

#[injectable]
impl StdoutLogger {
    #[inject]
    pub fn new() -&gt; StdoutLogger {
        StdoutLogger
    }
}

impl Logger for StdoutLogger {
    fn log(&amp;self, msg: &amp;str) {
        println!(&quot;{}&quot;, msg);
    }
}
</code></pre>
<p><code>#[binds]</code> can be used to create binding that says &quot;when the <code>Logger</code> interface is needed,
use <code>StdoutLogger</code> as the actual implementation&quot;:</p>
<pre><code class="language-rust no_run noplayground">    #[binds]
    pub fn bind_stdout_logger(_impl: StdoutLogger) -&gt; Cl&lt;dyn Logger&gt; {}
</code></pre>
<p>The method body must be empty, as Lockjaw will replace it.</p>
<p>The<a href="https://docs.rs/lockjaw/0.2.0/lockjaw/enum.Cl.html"><code>Cl</code></a> in the return type means
<strong>C</strong>omponent <strong>l</strong>ifetimed, which is a wrapper around a type forcing it not outlive the component.
Having this wrapper makes it easier for the compiler to deduce the lifetime.</p>
<p>With the binding defined the <code>Logger</code> can now be used by other classes, without caring about the
actual implementation.</p>
<pre><code class="language-rust no_run noplayground">pub struct Greeter&lt;'component&gt; {
    logger: Cl&lt;'component, dyn Logger&gt;,
}

#[injectable]
impl Greeter&lt;'_&gt; {
    #[inject]
    pub fn new(logger: Cl&lt;dyn Logger&gt;) -&gt; Greeter {
        Greeter { logger }
    }

    pub fn greet(&amp;self) {
        self.logger.log(&quot;helloworld!&quot;);
    }
}
</code></pre>
<p>Note that <code>Logger</code> still has to be injected as <code>Cl&lt;dyn Logger&gt;</code>, and <code>Greeter</code> is also bound by the
lifetime of the component.</p>
<h2 id="unit-testing-with-dependency-injection"><a class="header" href="#unit-testing-with-dependency-injection">Unit testing with dependency injection</a></h2>
<p><code>StdoutLogger</code> writes its output straight to the console, so it is hard to verify <code>Greeter</code> actually
sends the correct thing. While we can give <code>StdoutLogger</code> special apis to memorize what it logs and
give access to tests, having test code in prod is generally bad practice.</p>
<p>Instead we can use dependency injection to replace the environment <code>Greeter</code> runs in. We can create
a <code>TestLogger</code> that writes the logs to memory and can read it later, bind it to the <code>Logger</code> with a
module, and install the module in a component for test that has all test bindings. We are than able
to test <code>Greeter</code> without adding test code to the <code>Greeter</code> itself:</p>
<pre><code class="language-rust no_run noplayground">#[cfg(test)]
pub mod testing {
    use crate::{Greeter, Logger};
    use lockjaw::{component, injectable, module, Cl};

    static mut MESSAGES: Vec&lt;String&gt; = Vec::new();

    pub struct TestLogger;

    #[injectable]
    impl TestLogger {
        #[inject]
        pub fn new() -&gt; TestLogger {
            TestLogger
        }

        pub fn get_messages(&amp;self) -&gt; Vec&lt;String&gt; {
            unsafe { MESSAGES.clone() }
        }
    }

    impl Logger for TestLogger {
        fn log(&amp;self, msg: &amp;str) {
            unsafe { MESSAGES.push(msg.to_owned()) }
        }
    }

    pub struct TestModule;

    #[module]
    impl TestModule {
        #[binds]
        pub fn bind_test_logger(_impl: TestLogger) -&gt; Cl&lt;dyn Logger&gt; {}
    }

    #[component(modules: [TestModule])]
    pub trait TestComponent {
        fn greeter(&amp;self) -&gt; Greeter;
        fn test_logger(&amp;self) -&gt; TestLogger;
    }

    #[test]
    fn test() {
        let component: Box&lt;dyn TestComponent&gt; = &lt;dyn TestComponent&gt;::build();

        component.greeter().greet();

        assert_eq!(
            component.test_logger().get_messages(),
            vec![&quot;helloworld!&quot;.to_owned()]
        );
    }
}

</code></pre>
<p>Generally, a library should also provide a test implementation and a module that binds the test
implementation. The consumer of the library can then test by installing the test module instead of
the real module. This allows test infrastructure to easily be shared. Some kind of test scaffolding
can also be created to auto generate the component and inject objects into tests, but that is out of
scope for lockjaw itself.</p>
<p>Note that in the <code>TestLogger</code> <code>MESSAGES</code> is a static mutable, since <code>log()</code> and <code>get_messages()</code> is
going to be called on different instances of <code>TestLogger</code>. This is <code>unsafe</code> and bad, so in the next
chapter we will discuss how to handle this by forcing a single instance of <code>TestLogger</code> to be shared
among everything that uses it.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/binds/">Source</a> of this chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-bindings"><a class="header" href="#scoped-bindings">Scoped Bindings</a></h1>
<p>By default everytime a dependency needs to be satisfied, lockjaw creates a new instance, and move it
to the dependency (field or method parameter). This is not always desired since an object may be
used to carry some common state, and we want every type that depends on it to get a reference to a
single instance instead (singletons).</p>
<p>In the last chapter, we had to use a mutable static state to store the messages <code>TestLogger</code> logs,
since we need to read the same messages later but a different instance of <code>TestLogger</code> will be
created.</p>
<p>To do this, the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.injectable.html#scope"><code>scope</code> metadata</a>
can be specified on a <code>#[injecatable]</code> or <code>#[provides]</code>
, passing a component's path. This means there are only one instance of the type for objects created
by the same instance of component (they are not global singletons, you can still have multiple
instances if you have multiple components).</p>
<pre><code class="language-rust no_run noplayground">    #[derive(Default)]
    pub struct TestLogger {
        messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    #[injectable(scope: TestComponent)]
    impl TestLogger {
        #[inject]
        pub fn new() -&gt; TestLogger {
            TestLogger::default()
        }

        pub fn get_messages(&amp;self) -&gt; Vec&lt;String&gt; {
            self.messages.borrow().clone()
        }
    }

    impl Logger for TestLogger {
        fn log(&amp;self, msg: &amp;str) {
            self.messages.borrow_mut().push(msg.to_owned())
        }
    }

</code></pre>
<p>Other types can depend on a scoped type as a reference (<code>&amp;T</code>) or <code>Cl&lt;T&gt;</code></p>
<pre><code class="language-rust no_run noplayground">        fn test_logger(&amp;self) -&gt; Cl&lt;TestLogger&gt;;
    }

    #[test]
    fn test() {
        let component: Box&lt;dyn TestComponent&gt; = &lt;dyn TestComponent&gt;::build();

        component.greeter().greet();

        assert_eq!(
            component.test_logger().get_messages(),
            vec![&quot;helloworld!&quot;.to_owned()]
        );
    }
}

epilogue!();
</code></pre>
<p>Although <code>#[binds]</code> has to explicitly ask for <code>&amp;TestLogger</code></p>
<pre><code class="language-rust no_run noplayground">        #[binds]
        pub fn bind_test_logger(_impl: &amp;TestLogger) -&gt; Cl&lt;dyn Logger&gt; {}
</code></pre>
<p>Note that <code>Greeter</code> hasn't changed at
all. <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/enum.Cl.html"><code>Cl&lt;T&gt;</code></a> allows a type to decouple itself
from whether the type depended on is scoped or not. It may be an owned instance or a shared
instance, but the type does not care as it will not try to move it.</p>
<h2 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h2>
<p>Scoped objects are owned by the component and has the same lifetime as it.</p>
<h2 id="handling-mutability"><a class="header" href="#handling-mutability">Handling mutability</a></h2>
<p>In most uses a scoped type probably should be mutable to make it useful. However we cannot request
it as <code>&amp;mut T</code> since certainly multiple objects will try to request it. Scoped types must
implement <a href="https://doc.rust-lang.org/reference/interior-mutability.html">interior mutability</a> itself
and use an immutable interface. In the example <code>TestLogger</code> use
a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> so the messages can be mutated
even when the <code>TestLogger</code> itself is immutable.</p>
<p>Sometimes it might be easier to wrap the whole class in a memory container like a <code>RefCell</code>
or <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>.
The <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.injectable.html#container"><code>container</code> metadata</a>
can be used on a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.injectable.html"><code>#[injectable]</code></a> to
bind the type as <code>&amp;CONTAINER&lt;T&gt;</code> instead of <code>&amp;T</code> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qualifiers"><a class="header" href="#qualifiers">Qualifiers</a></h1>
<p>Sometimes users may need multiple shared instances of the same type for different purposes. For
example the application may need
different <a href="https://docs.rs/futures/0.3.16/futures/executor/struct.ThreadPool.html"><code>ThreadPool</code></a>:</p>
<ul>
<li>A thread pool for UI with a single thread, since OpenGL does not like concurrency.</li>
<li>A thread pool for general purpose CPU bound tasks, with a thread for each physical core.</li>
<li>A thread pool for IO bound tasks, with a small amount of threads. It is IO bound so more threads
won't make it faster</li>
<li>A thread pool for other blocking tasks with unbounded threads. Most of them will be idling anyway.</li>
</ul>
<p>They all share the same type/interface, but have different internal characteristics. Trying to bind
them all will cause duplicated binding failures. Furthermore, the user need to be able to specify
which one they want.</p>
<h2 id="new-type-idiom"><a class="header" href="#new-type-idiom">New type idiom</a></h2>
<p>In most cases,
the <a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html#new-type-idiom">new type idiom</a>
is preferred. With new types, Lockjaw sees them as unrelated and won't cause duplicated binding
issues. The compiler also provides strong compile time type check to ensure the correct one is used
(an API that do IO work can explicitly ask for the IoThreadPool).</p>
<p>However, the new type idiom does not work with bindings with type generated by Lockjaw such
as <a href="provider.html">providers</a>, <a href="optional.html">optional bindings</a>,
and <a href="multibindings.html">multibinding containers</a>. It may also cause a lot of wrapping/unwrapping when
working with third party libraries.</p>
<h2 id="qualifiers-1"><a class="header" href="#qualifiers-1">Qualifiers</a></h2>
<p>Qualifiers are hints for Lockjaw to give a type different tags, so they can be bound separately.</p>
<p>A qualifier must be declared first using
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.qualifier.html"><code>#[qualifier]</code></a> attribute macro.</p>
<pre><code class="language-rust no_run noplayground">#[qualifier]
pub struct Q1;

</code></pre>
<p>The struct body does not matter and probably should be empty.</p>
<p>Once the qualifier is declared, it can then be used in
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.qualified.html"><code>#[qualified]</code></a>
attribute on a method in a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.module.html"><code>#[module]</code></a>,
marking the return type as qualified. Lockjaw will treat the bindings as distinct types.</p>
<pre><code class="language-rust no_run noplayground">#[module]
impl MyModule {
    #[provides]
    pub fn provide_string() -&gt; String {
        &quot;string&quot;.to_owned()
    }

    #[provides]
    #[qualified(Q1)]
    pub fn provide_q1_string() -&gt; String {
        &quot;q1_string&quot;.to_owned()
    }

    #[provides]
    #[qualified(Q2)]
    pub fn provide_q2_string() -&gt; String {
        &quot;q2_string&quot;.to_owned()
    }
}
</code></pre>
<p>Qualified types can be injected using
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/component_attributes/attr.qualified.html"><code>#[qualified]</code></a>
attribute on the parameter, or the component method.</p>
<pre><code class="language-rust no_run noplayground">#[component(modules: [MyModule])]
pub trait MyComponent {
    fn string(&amp;self) -&gt; String;
    #[qualified(Q1)]
    fn q1_string(&amp;self) -&gt; String;
    #[qualified(Q2)]
    fn q2_string(&amp;self) -&gt; String;
}
</code></pre>
<pre><code class="language-rust no_run noplayground">    #[inject]
    pub fn new(#[qualified(Q)] s: String) -&gt; Foo {
        Foo { s }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="providert"><a class="header" href="#providert"><code>Provider&lt;T&gt;</code></a></h1>
<p>Normally when injecting a dependency, <em>one</em> instance of the dependency is <em>created before</em> creating
the depending object. This may not be ideal since the depending object might:</p>
<ul>
<li>Want multiple instance of the object, for example, populating an array.</li>
<li>Have cyclic dependency at <strong>runtime</strong></li>
</ul>
<p>For every binding <code>T</code>, Lockjaw also automatically creates a binding
to <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/struct.Provider.html"><code>Provider&lt;T&gt;</code></a>, which creates a new
instance of <code>T</code>
everytime <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/struct.Provider.html#method.get"><code>get()</code></a>  is
called.</p>
<p>Since a <code>Provider</code> needs to use the component to create the instance, its lifetime is bound by the
component.</p>
<h2 id="creating-multiple-instances"><a class="header" href="#creating-multiple-instances">Creating multiple instances</a></h2>
<p><code>Provider&lt;T&gt;</code> can be used to create instances on request.</p>
<pre><code class="language-rust no_run noplayground">struct Foo {
  bar_provider: Provider&lt;Bar&gt;,
  bars : Vec&lt;Bar&gt;,
}

impl Foo{
    #[inject]
    pub fn new(bar_provider: Provider&lt;Bar&gt;) -&gt; Foo {
      bar_provider,
      bars: vec![bar_provider.get(), bar_provider.get(), bar_provider.get()],
    }
    
    pub fn add_more_bar(&amp;mut self){
       self.bars.push(self.bar_provider.get())
    }
}
</code></pre>
<h2 id="bypassing-runtime-cyclic-dependency"><a class="header" href="#bypassing-runtime-cyclic-dependency">Bypassing runtime cyclic dependency</a></h2>
<p>Since regular dependencies must be created before instantiating an object, cyclic dependencies will
result in a recursive stack overflow when the constructor is called. Lockjaw will detect this
situation and refuse to compile your project.</p>
<p>However sometimes the dependency is only used at runtime, not at object construction. This is
especially common when singleton classes need to refer to each other. By using
<code>Provider&lt;T&gt;</code> the cycle can be broken.</p>
<pre><code class="language-rust no_run noplayground">struct Foo&lt;'component&gt; {
    bar_provider: Provider&lt;'component, Box&lt;Bar&lt;'component&gt;&gt;&gt;,
}

#[injectable]
impl&lt;'component&gt; Foo&lt;'component&gt; {
    #[inject]
    pub fn new(bar: Provider&lt;'component, Box&lt;Bar&lt;'component&gt;&gt;&gt;) -&gt; Foo&lt;'component&gt; {
        Self { bar_provider: bar }
    }

    pub fn create_bar(&amp;self) -&gt; Box&lt;Bar&lt;'component&gt;&gt; {
        self.bar_provider.get()
    }
}

struct Bar&lt;'component&gt; {
    foo: Box&lt;Foo&lt;'component&gt;&gt;,
}

#[injectable]
impl&lt;'component&gt; Bar&lt;'component&gt; {
    #[inject]
    pub fn new(foo: Box&lt;Foo&lt;'component&gt;&gt;) -&gt; Bar&lt;'component&gt; {
        Self { foo }
    }
}
</code></pre>
<p>In this example, while instantiating <code>Bar</code>, instantiates a <code>Foo</code>, <code>Bar</code> won't be created
until <code>Foo.create_bar()</code> is called, hence creating either won't trigger a stack overflow.</p>
<p>Trying to call <code>Provider.get</code> may still lead to a stack overflow, and Lockjaw cannot check this for
you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy"><a class="header" href="#lazy">Lazy</a></h1>
<p><a href="https://docs.rs/lockjaw/0.2.0/lockjaw/struct.Lazy.html"><code>Lazy&lt;T&gt;</code></a> is a wrapper around
a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/struct.Provider.html"><code>Provider&lt;T&gt;</code></a>, which creates the
object once and caches the result. The object will only be created
when <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/struct.Lazy.html#method.get"><code>get()</code></a> is called, and
subsequent invocations returns a reference to the same object.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/lazy.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory"><a class="header" href="#factory">Factory</a></h1>
<p>Sometimes an object needs not only injected values but also runtime values to be created, such as
constructor parameters that depends on user input.</p>
<p>This can be handled by writing a factory that injects bindings as a <a href="provider.html">Provider</a>, and
combine it with the runtime value to create the object. For example,</p>
<pre><code class="language-rust no_run noplayground">pub struct Foo {
    pub i: i32, // runtime
    pub s: String, // injected
}

pub struct FooFactory&lt;'component&gt;{
    s_provider: Provider&lt;'component, String&gt;
}

#[injectable]
impl FooFacotory&lt;'_&gt; {
    #[inject]
    pub fn new(s_provider: Provider&lt;String&gt;) -&gt; FooFactory {
       FooFactory { s_provider }
    }
    
    pub fn create(&amp;self, i: i32) -&gt; Foo {
       Foo { i, s : self.s_provider.get() }
    }
}
</code></pre>
<p>This is a lot of boilerplate, and can be automated by
using <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/injectable_attributes/attr.factory.html"><code>#[factory]</code></a>
instead
of <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a></p>
<pre><code class="language-rust no_run noplayground">#[injectable]
impl Foo {
    #[factory]
    fn create(#[runtime] i: i32, s: String) -&gt; Self {
        Self { i, s }
    }
}
</code></pre>
<p>Runtime parameters needs to be marked with
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/injectable_attributes/attr.factory.html#runtime"><code>#[runtime]</code></a>
attribute.</p>
<p><code>FooFactory</code> will be created by Lockjaw, with a method with the same name as the marked method
taking only runtime parameters.</p>
<pre><code class="language-rust no_run noplayground">    let foo = component.foo_factory().create(42);
</code></pre>
<h2 id="factory-traits"><a class="header" href="#factory-traits">Factory traits</a></h2>
<p>The factory can also be instructed to implement a <code>trait</code> by using the
<a href="https://docs.rs/lockjaw/0.2.0/lockjaw/injectable_attributes/attr.factory.html#implementing"><code>implementing</code> metadata</a>
.</p>
<pre><code class="language-rust no_run noplayground">pub trait FooCreator {
    fn create(&amp;self, i: i32) -&gt; Foo;
}

#[injectable]
impl Foo {
    #[factory(implementing: FooCreator)]
    fn create(#[runtime] i: i32, phrase: String) -&gt; Self {
        Self { i, phrase }
    }
}
</code></pre>
<p>The method name and runtime signature must match the <code>trait</code> method the factory should override.</p>
<p>This is especially useful to bind the factory to a trait</p>
<pre><code class="language-rust no_run noplayground">    #[binds]
    pub fn bind_foo_creator(impl_: FooFactory) -&gt; Cl&lt;dyn FooCreator&gt; {}
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/injectable_factory.rs
https://github.com/azureblaze/lockjaw/blob/main/tests/injectable_factory_implementing.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optional-bindings"><a class="header" href="#optional-bindings">Optional bindings</a></h1>
<p>Sometimes a binding might be optional, being behind
a <a href="https://doc.rust-lang.org/cargo/reference/features.html">cargo feature</a> or provided by an
optional library. It will be useful to allow such bindings to be missing from the dependency graph,
and detect whether such binding exists.</p>
<p>In Lockjaw a binding can be declared as optional by using
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.binds_option_of.html">#[binds_option_of]</a>
method attribute in a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.module.html">#[module]</a></p>
<pre><code class="language-rust no_run noplayground">    #[binds_option_of]
    pub fn binds_option_of_string() -&gt; String {}
</code></pre>
<p>The <code>#[binds_option_of]</code> method should take no parameter and return the type <code>T</code> to bind
as <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a>. This does not actually bind
the <code>T</code>.</p>
<pre><code class="language-rust no_run noplayground">    fn option_string(&amp;self) -&gt; Option&lt;String&gt;;
</code></pre>
<p>If <code>T</code> is actually bound somewhere else, injecting <code>Option&lt;T&gt;</code> will result in <code>Some(T)</code>. Otherwise
it will be <code>None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multibinding"><a class="header" href="#multibinding">Multibinding</a></h1>
<p>Multibinding is a special type of binding in Lockjaw that allows duplicated bindings. Instead of
enforcing one binding per type, multibindings gather the bindings into a collection, allowing
&quot;everything implementing a type&quot; to be injected. This is especially useful to build a plugin system
where an unspecified amount of implementations can be handled.</p>
<p>Multibindings comes in 2 flavors, a <a href="vec.html"><code>Vec&lt;T&gt;</code> binding</a> that simply collects everything, and
<a href="map.html"><code>HashMap&lt;K,V&gt;</code> binding</a> where key collisions are checked at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vect-multibindings"><a class="header" href="#vect-multibindings"><code>Vec&lt;T&gt;</code> multibindings</a></h1>
<p>A <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a> or
<a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.binds.html"><code>#[binds]</code></a> binding can
also be marked with
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.into_vec.html"><code>#[into_vec]</code></a>
attribute, which means instead of directly binding to <code>T</code>, the binding should be collected into a
<code>Vec&lt;T&gt;</code>.</p>
<p>With the bindings:</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    #[into_vec]
    pub fn provide_string1() -&gt; String {
        &quot;string1&quot;.to_owned()
    }

    #[provides]
    #[into_vec]
    pub fn provide_string2() -&gt; String {
        &quot;string2&quot;.to_owned()
    }
</code></pre>
<p><code>Vec&lt;String&gt;</code> can be injected with the values <code>[&quot;string1&quot;, &quot;string2&quot;]</code>. This works across all
modules that are installed.</p>
<p><code>#[into_vec]</code> can also be <a href="qualifiers.html"><code>#[qualified]</code></a></p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    #[qualified(Q)]
    #[into_vec]
    pub fn provide_q_string1() -&gt; String {
        &quot;q_string1&quot;.to_owned()
    }
</code></pre>
<p>Which result in <code>#[qualified(Q)] Vec&lt;String&gt;</code>. Note that the container is qualified instead of the
content.</p>
<p><code>#[into_vec]</code> also works with <a href="binds.html"><code>#[binds]</code></a></p>
<pre><code class="language-rust no_run noplayground">    #[binds]
    #[into_vec]
    pub fn bind_bar(impl_: crate::Bar) -&gt; Cl&lt;dyn crate::Foo&gt; {}

    #[binds]
    #[into_vec]
    pub fn bind_baz(impl_: crate::Baz) -&gt; Cl&lt;dyn crate::Foo&gt; {}
</code></pre>
<p>Which allows <code>Vec&lt;Cl&lt;dyn Foo&gt;&gt;</code> to be injected. This is a common way to implement event callbacks.</p>
<h2 id="providing-multiple-items"><a class="header" href="#providing-multiple-items">Providing multiple items</a></h2>
<p>A method marked
with <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.elements_into_vec.html"><code>#[elements_into_vec]</code></a>
can return <code>Vec&lt;T&gt;</code>, which will get merged with other <code>#[into_vec]</code> and <code>#[elements_into_vec]</code>.</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    #[elements_into_vec]
    pub fn provide_strings() -&gt; Vec&lt;String&gt; {
        vec![&quot;string3&quot;.to_owned(), &quot;string4&quot;.to_owned()]
    }
</code></pre>
<p>This allows multiple bindings to be provided at once. It also allows a binding method to decide not
to provide anything at runtime, by returning an empty <code>Vec</code>.</p>
<h2 id="duplication-behaviors"><a class="header" href="#duplication-behaviors">Duplication behaviors</a></h2>
<p>Lockjaw's <code>#[into_vec]</code> strays from
Dagger's <a href="https://dagger.dev/api/latest/dagger/multibindings/IntoSet.html"><code>@IntoSet</code></a>, as <code>Hash</code>
and <code>Eq</code> are not universally implemented in Rust. This mean the <code>Vec</code> may contain duplicated values.</p>
<p>However, duplicated modules are not allowed by Lockjaw, so each binding method will be called at
most once when generating the <code>Vec</code>.</p>
<p>If deduplication is needed, you can add another provider that does the conversion:</p>
<pre><code class="language-rust no_run noplayground">#[provides]
pub fn vec_string_to_set_string(v: Vec&lt;String&gt;) -&gt; HashSet&lt;String&gt; {
    HashSet::from_iter(v)
}
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/module_provides_into_vec.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmapkv-multibinding"><a class="header" href="#hashmapkv-multibinding"><code>HashMap&lt;K,V&gt;</code> multibinding</a></h1>
<p>Similar to <a href="vec.html"><code>Vec&lt;T&gt; multibinding</code></a>,
a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a> or
<a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.binds.html"><code>#[binds]</code></a> binding can
also be marked with
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.into_map.html"><code>#[into_map]</code></a>
attribute, which collects the key-value pair into
a <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a></p>
<p>While a map can be created by multibinding <code>Vec&lt;(K,V)&gt;</code> or some other entry generating mechanisms,
the <code>HashMap&lt;K,V&gt;</code> multibinding has additional compile time checks to make sure there are no key
collisions.</p>
<h2 id="map-keys"><a class="header" href="#map-keys">Map keys</a></h2>
<p>The value type is specified by the binding method return value, but the key type and value needs to
be specified by a metadata in the <code>#[into_map]</code> attribute.</p>
<h3 id="string_key"><a class="header" href="#string_key"><code>string_key</code></a></h3>
<p><code>string_key</code> specifies the map key is
a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>. The value must be a string
literal, lockjaw is unable to resolve more complex compile time constants.</p>
<p>This example binds to <code>HashMap&lt;String,String&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    #[into_map(string_key: &quot;1&quot;)]
    pub fn provide_string1() -&gt; String {
        &quot;string1&quot;.to_owned()
    }

    #[provides]
    #[into_map(string_key: &quot;2&quot;)]
    pub fn provide_string2() -&gt; String {
        &quot;string2&quot;.to_owned()
    }
</code></pre>
<h3 id="i32_key"><a class="header" href="#i32_key"><code>i32_key</code></a></h3>
<p><code>i32_key</code> specifies the map key is an <code>i32</code>. The value must be an i32 literal, lockjaw is unable to
resolve more complex compile time constants.</p>
<p>This example binds to <code>HashMap&lt;i32,String&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    #[into_map(i32_key: 1)]
    pub fn provide_i32_string1() -&gt; String {
        &quot;string1&quot;.to_owned()
    }

    #[provides]
    #[into_map(i32_key: 2)]
    pub fn provide_i32_string2() -&gt; String {
        &quot;string2&quot;.to_owned()
    }
</code></pre>
<p>Other types are not implemented. <code>i32</code> ought to be enough for everyone.</p>
<h3 id="enum_key"><a class="header" href="#enum_key"><code>enum_key</code></a></h3>
<p><code>i32_key</code> specifies the map key is an <code>enum</code>. Since the <code>enum</code> is going to be used as the map key,
it must satisfy the same constraints <code>HashMap</code> gives, which is
implementing <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>
and <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>. It also must be a simple enum with
no fields so Lockjaw knows how to compare them at compile time (meaning comparing the name is
enough).</p>
<pre><code class="language-rust no_run noplayground">#[derive(Eq, PartialEq, Hash)]
pub enum E {
    Foo,
    Bar,
}
</code></pre>
<p>This example binds to <code>HashMap&lt;E,String&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    #[into_map(enum_key: E::Foo)]
    pub fn provide_enum_string1() -&gt; String {
        &quot;string1&quot;.to_owned()
    }

    #[provides]
    #[into_map(enum_key: Bar)]
    pub fn provide_enum_string2() -&gt; String {
        &quot;string2&quot;.to_owned()
    }
</code></pre>
<p>Lockjaw is able to infer the enum type (<code>E</code>) if the value is imported (<code>use E::Bar</code>), but the code
maybe be more readable if the type is explicitly spelled out, especially most IDEs today cannot
properly inspect tokens inside the metadata.</p>
<h2 id="qualifiers-2"><a class="header" href="#qualifiers-2">Qualifiers</a></h2>
<p><code>#[into_map]</code> can also be <a href="qualifiers.html"><code>#[qualified]</code></a></p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    #[qualified(Q)]
    #[into_map(string_key: &quot;1&quot;)]
    pub fn provide_q_string1() -&gt; String {
        &quot;q_string1&quot;.to_owned()
    }
</code></pre>
<p>Which result in <code> #[qualified(Q)] HashMap&lt;String, String&gt;</code>. Note that the container is qualified
instead of the content.</p>
<h2 id="dynamic-map-entries"><a class="header" href="#dynamic-map-entries">Dynamic map entries</a></h2>
<p>All bindings in <code>#[into_map]</code> must be resolved at compile time, There are
no <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.elements_into_vec.html"><code>#[elements_into_vec]</code></a>
equivalent such as <code>#[elements_into_map]</code>.</p>
<p>However dynamic map entries can be achieved by rebinding <code>Vec&lt;(K,V)&gt;</code> into a <code>HashMap&lt;K,V&gt;</code>.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/module_provides_into_map.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empty-multibindings"><a class="header" href="#empty-multibindings">Empty multibindings</a></h1>
<p>The binding for <code>Vec&lt;T&gt;</code> and <code>HashMap&lt;K,V&gt;</code> is automatically generated when <a href="vec.html"><code>#[into_vec]</code></a>
or <a href="map.html"><code>#[into_map]</code></a> is encountered. However when such binding does not exist and someone
depended on the collection, Lockjaw cannot be sure if it should provide an empty collection since it
should be a multibinding, or if the user forgot to bind the collection.</p>
<p>This usually happens when a library defines a multibinding for events, etc., but does not bind
anything to it itself, and clients aren't forced to use the event.</p>
<p>A <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/module_attributes/attr.multibinds.html"><code>#[multibinds]</code></a>
method that returns the collection type should be declared in such case, to let Lockjaw know a
multibinding collection is intended, but it may be empty.</p>
<pre><code class="language-rust no_run noplayground">#[module]
impl MyModule {
    #[multibinds]
    fn vec_string() -&gt; Vec&lt;String&gt; {}

    #[multibinds]
    #[qualified(Q)]
    fn q_vec_string() -&gt; Vec&lt;String&gt; {}

    #[multibinds]
    fn map_string_string() -&gt; HashMap&lt;String, String&gt; {}

    #[multibinds]
    #[qualified(Q)]
    fn q_map_string_string() -&gt; HashMap&lt;String, String&gt; {}
}
</code></pre>
<p><code>#[multibinds]</code> also serves as documentation on the <code>#[module]</code> specifying it is expecting the
multibinding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subcomponents"><a class="header" href="#subcomponents">Subcomponents</a></h1>
<p><a href="scoped.html">Scopes</a> enforces an object to be a singleton within the component, so everyone can
interact with the same instance. However there are times when we need multiple sets of such
instances. For example, we might be implementing a web server, and there are a lot of shared
resources with every session. We want the session to be independent, so we need to create component
for each session:</p>
<pre><code class="language-rust no_run noplayground">impl Server {
    pub fn new_session(url: Url) -&gt; Session {
      Session{
         component: &lt;dyn SessionComponent&gt;::build({url,...})
      }
    }
}
</code></pre>
<p>However, there are also some resource that belongs to the whole server shared by all sessions, for
example, an IO bound thread pool. We have to rebind this in every <code>SessionComponent</code></p>
<pre><code class="language-rust no_run noplayground">impl Server{
    #[inject]
    pub fn new(#[qualified(IoBound)] io_threadpool: &amp;ThreadPool) { ... }
    
        pub fn new_session(&amp;self, url: Url) -&gt; Session {
        Session {
            component: &lt;dyn SessionComponent&gt;::build({
                url,
                self.io_threadpool,
                ...
            })
        }
    }
}
</code></pre>
<p>Managing these will soon get ugly.</p>
<p>Instead we can create
a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.subcomponent.html"><code>#[subcomponent]</code></a> which can have
distinct scoped bindings, modules, but also has access to bindings in its parent component.</p>
<p>Using <code>#[subcomponent]</code> is almost identical to a regular <code>#[component]</code>, except that the
<code>#[subcomponent]</code> has to be installed in a parent component, and the method to create an instance.</p>
<h2 id="installing-a-subcomponent"><a class="header" href="#installing-a-subcomponent">Installing a <code>#[subcomponent]</code></a></h2>
<p>A <code>#[subcomponent]</code> is installed by first listing it in
a <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.module.html#"><code>#[module]</code></a> using
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.module.html#subcomponents"><code>subcomponents</code> metadata</a></p>
<pre><code class="language-rust no_run noplayground">#[module(subcomponents: [MySubcomponent])]
impl ParentComponentModule {
</code></pre>
<p>Then installing the <code>#[module]</code> in a parent component. The parent component can be either a regular
component or another subcomponent.</p>
<h2 id="creating-a-instance-of-the-subcomponent"><a class="header" href="#creating-a-instance-of-the-subcomponent">Creating a instance of the subcomponent</a></h2>
<p>The <code>#[module]</code> with a <code>subcomponents: [FooSubcomponent]</code> metadata creates hidden binding
of <code>Cl&lt;FooSubcomponentBuilder&gt;</code> which can be injected to create new instances of <code>FooSubcomponent</code>
by calling <code>build()</code>. <code>build()</code> also takes the
corresponding <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.builder_modules.html"><code>#[builder_modules]</code></a>
if the subcomponent is defined with
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html#builder_modules"><code>builder_modules</code> metadata</a></p>
<p><code>build</code> can be called multiple times to create independent subcomponents, with the parent being
shared.</p>
<h2 id="lifetime-1"><a class="header" href="#lifetime-1">Lifetime</a></h2>
<p>The lifetime of the subcomponent is bound by its parent.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/sub_component.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defined-components"><a class="header" href="#defined-components">Defined components</a></h1>
<p>One of the issues with
using <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.component.html#"><code>#[component]</code></a>
and <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.subcomponent.html"><code>#[subcomponent]</code></a> is that
modules still has to be listed, which means anything using the component will depend on everything.
The component is also generated in the crate, so other crates depending on it is not able to expand
the dependency graph, which makes <a href="multibindings.html">multibindings</a> less useful. Additionally, unit
tests often needs a different set of modules, so the whole component has to be redefined.</p>
<p>In a large project there maybe tens and even hundreds of modules, and this will become very
difficult to manage.</p>
<p>Instead of <code>#[component]</code> and <code>#[subcomponent]</code>, Lockjaw also
provides <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.define_component.html"><code>#[define_component]</code></a>
and<a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.define_subcomponent.html"><code>#[define_subcomponent]</code></a>
which automatically collects modules from the entire build dependency tree, so they no longer need
to be manually installed.</p>
<h1 id="root-crate"><a class="header" href="#root-crate">Root crate</a></h1>
<p>When using <code>#[define_component]</code> the component is not immediately generated, since modules from
crates depending on the current crate may still want to add to the dependency graph.</p>
<p>Lockjaw needs to know which crate is the root crate that is not depended on by other crates, which
is done by passing
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/macro.epilogue.html#root"><code>root</code> identifier</a> to
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/macro.epilogue.html"><code>epilogue!()</code> macro</a></p>
<pre><code>epilogue!(root);
</code></pre>
<p>Typically the root crate is the binary. Libraries can also be the root crate but that is probably
not a good idea. Lockjaw will fail compilation if a crate using it depends on another crate that is
a root crate.</p>
<h2 id="automatically-installing-modules"><a class="header" href="#automatically-installing-modules">Automatically installing modules</a></h2>
<p><a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.module.html"><code>#[modules]</code></a> can be automatically
installed in a component by using
the <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.module.html#install_in"><code>install_in</code> metadata</a>. The
metadata takes a path to a <code>#[define_component]</code> <code>trait</code>. Alternatively, it can also be a path to
<a href="https://docs.rs/lockjaw/latest/lockjaw/trait.Singleton.html"><code>Singleton</code></a>, which means it should be
installed in every <code>#[define_component]</code> but not <code>#[define_subcomponent]</code>.</p>
<p>Such modules cannot have fields.</p>
<pre><code class="language-rust no_run noplayground">#[module(install_in: MyComponent)]
impl MyModule {
    #[provides]
    pub fn provide_string() -&gt; String {
        &quot;string&quot;.to_owned()
    }
}

#[define_component]
pub trait MyComponent {
    fn string(&amp;self) -&gt; String;
}
</code></pre>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h2>
<p>Ideally a component should only be used at the program's entry point, and rest of the program should
all use dependency injection, instead of trying to pass the component around. However sometimes
callbacks will be called from non-injected context, and the user will need to reach back into the
component.</p>
<p>These kinds of usage will cause the <a href="request.html">requesting methods</a> in a component to bloat, and
add redundant dependencies or cycle issues to everyone that uses the component.</p>
<p>With <code>#[define_component]</code>
, <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.entry_point.html"><code>#[entry_point]</code></a> can be used.</p>
<p>An <code>#[entry_point]</code> has binding requesting methods just like a component.
The <a href=""><code>install_in</code> metadata</a> needs to be used to install the <code>#[entry_point]</code> in a component. Once
installed, the</p>
<pre><code class="language-rust no_run noplayground">&lt;dyn FooEntryPoint&gt;::get(component : &amp;dyn FooComponent) -&gt; &amp;dyn FooEntryPoint
</code></pre>
<p>method can be used to cast the opaque component into the entry point, and access the dependency
graph.</p>
<pre><code class="language-rust no_run noplayground">#[entry_point(install_in: MyComponent)]
pub trait MyEntryPoint {
    fn i(&amp;self) -&gt; i32;
}

#[define_component]
pub trait MyComponent {}

#[test]
pub fn main() {
    let component: Box&lt;dyn MyComponent&gt; = &lt;dyn MyComponent&gt;::new();

    assert_eq!(&lt;dyn MyEntryPoint&gt;::get(component.as_ref()).i(), 42)
}
</code></pre>
<h2 id="testing-with-define_component"><a class="header" href="#testing-with-define_component">Testing with <code>#[define_component]</code></a></h2>
<p>While compiling tests, Lockjaw gathers <code>install_in</code> modules only from the <code>[dev-dependencies]</code>
section of <code>Cargo.toml</code> instead of the regular <code>[dependencies]</code>, even though <code>[dev-dependencies]</code>
inherits <code>[dependencies]</code>. This is due to tests often have conflicting modules with prod code. any
prod modules that need to be used in tests has to be relisted again in the <code>[dev-dependencies]</code>
section. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caveats"><a class="header" href="#caveats">Caveats</a></h1>
<p>Due to limitations of Rust and the author's ignorance, some of lockjaw's APIs have bad ergonomics,
and some others have abusive implementation which may break any time as Rust evolves
(or even already broken on some platforms). Beware of these before using lockjaw.</p>
<h2 id="abusive"><a class="header" href="#abusive">Abusive</a></h2>
<p>These are things lockjaw do that are probably not recommended, and may easily break in the future.</p>
<h3 id="persistent-mutable-state-between-proc_macro-invocations"><a class="header" href="#persistent-mutable-state-between-proc_macro-invocations">Persistent mutable state between proc_macro invocations</a></h3>
<p>Lockjaw proc_macros are not independent. Most macros only gather type data in memory, which is then
compiled to a dependency graph and used to generate the component codes.</p>
<p>Rust does not have any guarantee when proc_macros are executed, the order they are executed, the
threads they are executed on, or even the process they are executed on. This can easily break if the
compilation mode changes, such as incremental compilation (some proc_marco are not re-invoked) and
multi-threaded compilation (lockjaw macros has strict order dependency. For example <code>epilogue!()</code>
must be the last invoked lockjaw macro).</p>
<p>It would be nice if rust somehow allows proc_macro to generate pieces of serializable metadata that
can be read by other proc_macros.</p>
<h3 id="proc_macro-writes-data-to-build-script-out_dir"><a class="header" href="#proc_macro-writes-data-to-build-script-out_dir">proc_macro writes data to build script OUT_DIR</a></h3>
<p>To handle cross-crate dependencies, lockjaw writes the bindings metadata to OUT_DIR so other crates
can read it later.</p>
<p>Rust only specifies the build script should write to OUT_DIR, while proc_macro seems to run on the
same process and has the environment variable (when there is a build script, so lockjaw forces the
user to use a build script even though it is doing nothing).</p>
<h3 id="proc_macro-reads-data-from-disk"><a class="header" href="#proc_macro-reads-data-from-disk">proc_macro reads data from disk</a></h3>
<p>Same as above, lockjaw proc_macro reads data from other crates output so cross-crate dependency
graph can be generated.</p>
<h3 id="proc_macro-writes-data-to-other-crates-out_dir"><a class="header" href="#proc_macro-writes-data-to-other-crates-out_dir">proc_macro writes data to other crate's OUT_DIR</a></h3>
<p>Also for cross-crate dependency, the bindings metadata from other crates are required. While lockjaw
can determine the crate's dependencies with <code>cargo tree</code> (proc_macro spawning processes is probably
also a bad idea), it has no idea where their OUT_DIR are.</p>
<p>The current solution is to hardcode the proc_macro library's OUT_DIR into itself with a build
script, and let other crates that uses lockjaw also write their OUT_DIR to the proc_macro library's
OUT_DIR so it can be looked up later. Mutating data outside a crate's bound seems really bad.</p>
<p>This can be solved if:</p>
<ul>
<li>Rust allow looking up OUT_DIR of crates depended on.</li>
<li>Rust allow compile time reflection such as inspecting whether a const string exists and reading
its value, so the metadata can be encoded.</li>
</ul>
<h2 id="bad-ergonomic"><a class="header" href="#bad-ergonomic">Bad ergonomic</a></h2>
<p>Some restrictions in the API causes additional work/confusion to users.</p>
<h3 id="unable-to-resolve-types"><a class="header" href="#unable-to-resolve-types">Unable to resolve types</a></h3>
<p>proc_macro are invoked at the token phase, so there are no type information available. Lockjaw is
unable to resolve <code>use</code> or type aliases, and must force users to provide fully qualified path
where ever it needs to compare types.</p>
<p>To fix this Rust need to provide some other code generation mechanism that runs at later phases
with type information.</p>
<h3 id="unable-to-detect-path-to-current-item"><a class="header" href="#unable-to-detect-path-to-current-item">Unable to detect path to current item</a></h3>
<p>Lockjaw need users to call <code>mod_epilogue!()</code> to provide the path of the current file, and add the
<code>path=&quot;&quot;</code> metadata to some attributes, so it can figure out the fully qualified path of a binding.</p>
<p>This can be improved if <a href="https://github.com/rust-lang/rfcs/pull/2320">eager macro expansion</a> is
implemented, where lockjaw can insert <code>module_path!()</code> where needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h1>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of
experience, education, socio-economic status, nationality, personal appearance,
race, religion, or sexual identity and orientation.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to creating a positive environment
include:</p>
<ul>
<li>Using welcoming and inclusive language</li>
<li>Being respectful of differing viewpoints and experiences</li>
<li>Gracefully accepting constructive criticism</li>
<li>Focusing on what is best for the community</li>
<li>Showing empathy towards other community members</li>
</ul>
<p>Examples of unacceptable behavior by participants include:</p>
<ul>
<li>The use of sexualized language or imagery and unwelcome sexual attention or
advances</li>
<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or electronic
address, without explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a
professional setting</li>
</ul>
<h2 id="our-responsibilities"><a class="header" href="#our-responsibilities">Our Responsibilities</a></h2>
<p>Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.</p>
<p>Project maintainers have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, or to ban temporarily or permanently any
contributor for other behaviors that they deem inappropriate, threatening,
offensive, or harmful.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.</p>
<p>This Code of Conduct also applies outside the project spaces when the Project
Steward has a reasonable belief that an individual's behavior may have a
negative impact on the project or its community.</p>
<h2 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h2>
<p>We do not believe that all conflict is bad; healthy debate and disagreement
often yield positive results. However, it is never okay to be disrespectful or
to engage in behavior that violates the projects code of conduct.</p>
<p>If you see someone violating the code of conduct, you are encouraged to address the behavior
directly with those involved. Many issues can be resolved quickly and easily, and this gives people
more control over the outcome of their dispute. If you are unable to resolve the matter for any
reason, or if the behavior is threatening or harassing, report it. We are dedicated to providing an
environment where participants feel welcome and safe.</p>
<p>Reports should be directed to azureblaze, the Project Steward(s) for Lockjaw. It is the Project
Stewards duty to receive and address reported violations of the code of conduct. They will then
work with a committee consisting of representatives from the Open Source Programs Office and the
Google Open Source Strategy team. If for any reason you are uncomfortable reaching out to the
Project Steward, please email opensource@google.com.</p>
<p>We will investigate every complaint, but you may not receive a direct response. We will use our
discretion in determining when and how to follow up on reported incidents, which may range from not
taking action to permanent expulsion from the project and project-sponsored spaces. We will notify
the accused of the
report and provide them an opportunity to discuss it before any action is taken.
The identity of the reporter will be omitted from the details of the report
supplied to the accused. In potentially harmful situations, such as ongoing
harassment or threats to anyone's safety, we may take action without notice.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4,
available at
https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to Contribute</a></h1>
<p>We'd love to accept your patches and contributions to this project. There are
just a few small guidelines you need to follow.</p>
<h2 id="contributor-license-agreement"><a class="header" href="#contributor-license-agreement">Contributor License Agreement</a></h2>
<p>Contributions to this project must be accompanied by a Contributor License
Agreement. You (or your employer) retain the copyright to your contribution;
this simply gives us permission to use and redistribute your contributions as
part of the project. Head over to <a href="https://cla.developers.google.com/">https://cla.developers.google.com/</a> to see
your current agreements on file or to sign a new one.</p>
<p>You generally only need to submit a CLA once, so if you've already submitted one
(even if it was for a different project), you probably don't need to do it
again.</p>
<h2 id="code-reviews"><a class="header" href="#code-reviews">Code reviews</a></h2>
<p>All submissions, including submissions by project members, require review. We
use GitHub pull requests for this purpose. Consult
<a href="https://help.github.com/articles/about-pull-requests/">GitHub Help</a> for more
information on using pull requests.</p>
<h2 id="community-guidelines"><a class="header" href="#community-guidelines">Community Guidelines</a></h2>
<p>This project follows <a href="https://opensource.google/conduct/">Google's Open Source Community
Guidelines</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
