<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lockjaw User Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lockjaw User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Lockjaw is a fully static, compile-time
<a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> framework for
<a href="https://www.rust-lang.org/">Rust</a> inspired by <a href="https://dagger.dev">Dagger</a>.</p>
<h2 id="why-use-a-dependency-injection-framework"><a class="header" href="#why-use-a-dependency-injection-framework">Why use a dependency injection framework</a></h2>
<p>The main purpose of dependency injection is to separate the concerns of creating an object and using
an object. In larger projects creating an object soon becomes a complicated process since creating
an object ofter requires other objects that needs to be created first(a dependency). Once the object
dependency graph grows deep and wide adding a new edge or node becomes a painful endeavor. For
example, you may need to modify the signature of a dozen methods and interfaces just to pass the new
object all the way to the site it is actually going to be used. This often ends up with
anti-patterns like god objects and global states holding objects so the path can be shortened.</p>
<p>The dependency injection <em>technique</em> alleviates this problem by making an object only receive the
objects they need. The object no longer needs to know what is required to create those objects, nor
will have any change if their indirect dependency changes. Responsibility for creating objects is
moved to factories.</p>
<p>A dependency injection <em>framework</em> further manages this by automating the creation of the factories.
Users simply specify what each object needs, which implementation to use for an interface, etc., and
the objects can be created.</p>
<h2 id="why-use-lockjaw-as-the-dependency-injection-framework"><a class="header" href="#why-use-lockjaw-as-the-dependency-injection-framework">Why use Lockjaw as the dependency injection framework</a></h2>
<p>Lockjaw is inspired by <a href="https://dagger.dev">Dagger</a>, which is a mature dependency injection
framework for Java. Lockjaw has feature parity with Dagger (
except <a href="https://dagger.dev/dev-guide/producers">producers</a>, which may not be too useful in Rust with
async/await available.)</p>
<p>Main features:</p>
<ul>
<li>Compile time dependency resolution
<ul>
<li>Lockjaw makes sure all dependencies are fulfilled at compile time. The code will fail to
compile if a dependency is missing, there are duplicated bindings for the same type, or if the
dependency graph has cycles. There will be no runtime errors which are harder to detect.</li>
</ul>
</li>
<li><em>Relatively</em> readable diagnostic messages.
<ul>
<li>When a dependency is missing Lockjaw tries to tell you why it is even in the dependency graph,
and where the dependency cycle is.</li>
</ul>
</li>
<li>Cross-crate injection
<ul>
<li>Lockjaw is designed to be used across crates. Clients are able to inject bindings provided by
libraries if they also use Lockjaw.</li>
</ul>
</li>
<li>Minimal generated code surface
<ul>
<li>While procedural macros are utilized heavily by Lockjaw, it avoids directly modifying the code
the attributes macros are placed on. Only a few generated methods are visible to the user.
This is especially important since most Rust IDEs today does not understand the output of
procedural macros, a few extra type hints on <code>let</code> expressions is enough to make autocomplete
functional.</li>
</ul>
</li>
<li>Optional binding, Multibinding, and generated components for plugin systems
<ul>
<li>Lockjaw allows <a href="https://en.wikipedia.org/wiki/Inversion_of_control">inversion of control</a>
between library crates and their user. A library is able to define hooks for clients that
depends on the library to inject. This is especially useful to test multiple clients using a
library in isolation.</li>
</ul>
</li>
</ul>
<h2 id="why-not-use-lockjaw-as-the-dependency-injection-framework"><a class="header" href="#why-not-use-lockjaw-as-the-dependency-injection-framework">Why <em>NOT</em> use Lockjaw as the dependency injection framework</a></h2>
<p>While the generated code generally is OK-ish, abhorrent techniques are used to generate the code
under the confinement of the current Rust proc-macro system and is extremely fragile.</p>
<p>Please read the <a href="before.html">before using</a> chapter before using Lockjaw. Lockjaw currently cannot be
recommended for serious work in good conscious. <strong>YOU HAVE BEEN WARNED</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="before-using-lockjaw"><a class="header" href="#before-using-lockjaw">Before Using Lockjaw</a></h1>
<p>Before using lockjaw you should carefully consider if it is really for you. Having compile time
dependency injection is wonderful, but the current Rust proc-macro system does not make it easy, and
there are a lot of trade-offs.</p>
<h2 id="robustness"><a class="header" href="#robustness">Robustness</a></h2>
<p>Lockjaw is experimental in its nature, with the main goal of reaching feature parity with Dagger. It
tries to answer:</p>
<ul>
<li>What dependency injection would look like in Rust?
<ul>
<li>Is it even possible?</li>
<li>Is it going to be useful?</li>
<li>How should lifetimes and borrows be handled?</li>
</ul>
</li>
<li>What are the hurdles when trying to implement a dependency injection framework in Rust?</li>
</ul>
<p>Currently lockjaw focuses on "can" instead of "should". If there is any hacky undocumented compiler
behavior we can abuse to implement a feature, It <strong>will</strong> be used. While we try to make it bug-free
and generate safe code in the current version of Rust, there are no guarantee it will continue to
work in the future.</p>
<p>See the <a href="caveats.html">caveats</a> section for all horrible hacks used.</p>
<p>Future efforts might be made to get language features Lockjaw need implemented in Rust, but that is
a very long road.</p>
<h2 id="maintenance"><a class="header" href="#maintenance">Maintenance</a></h2>
<p>Lockjaw is a quite complicated project, but it is built by the developer with short attention span
and other priorities, as a hobby project, while also trying to learn Rust. Do not expect continuous
support, and especially consider that newer Rust can break Lockjaw at any moment.</p>
<h2 id="irreversibility"><a class="header" href="#irreversibility">Irreversibility</a></h2>
<p>Dependency injection frameworks are very invasive and will change how code are written. If you
decide to remove Lockjaw in the future, you may need to rewrite the whole project.</p>
<h2 id="only-use-lockjaw-if"><a class="header" href="#only-use-lockjaw-if">Only use lockjaw if...</a></h2>
<ul>
<li>You also like to live dangerously.</li>
<li>You are experimenting things.</li>
<li>You are working on a small project, and it won't be maintained in the future.</li>
<li>Someone else will be maintaining the project in the future, and you are a horrible individual.</li>
<li>You love dependency injection so much you are willing to patch bugs yourself, and freeze Rust
version if it breaks Lockjaw.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="binding"><a class="header" href="#binding">Binding</a></h2>
<p>A recipe to build an instance of a type. It includes dependencies (other types that needs to be
prepared first before the instance can be created), and a way to transform the dependencies into
a new instance, either by a user supplied method or Lockjaw internal generation.</p>
<h2 id="module"><a class="header" href="#module">Module</a></h2>
<p>In all Lockjaw documentations, "module" refers to a <em>dependency injection module</em>. When referring to
Rust modules <code>mod</code> will be used instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>Add lockjaw to the <code>[dependencies]</code> and <code>[build_dependencies]</code> section of your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
lockjaw = "*"

[build-dependencies]
lockjaw = "*"
</code></pre>
<p>The proc_macro and runtime library are packaged into the same crate, so this is the only target you
need. While the <code>proc_macro</code> library is heavy, Rust should be able to optimize them away in the
resulting binary. The runtime is pretty light, and the generated code is <em>supposed</em> to be zero cost
abstraction.</p>
<h2 id="build-script"><a class="header" href="#build-script">Build script</a></h2>
<p>Lockjaw also needs some environment setup, and requires a
<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a>. Add <code>build.rs</code> next to
<code>Cargo.toml</code>, and
call <a href="https://docs.rs/lockjaw/latest/lockjaw/fn.build_script.html"><code>lockjaw::build_script()</code></a>
in <code>main()</code> inside it:</p>
<pre><code class="language-rust no_run noplayground">// https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/build.rs
fn main() {
    lockjaw::build_script();
}</code></pre>
<p>Lockjaw will ask you to do this if this step is missing.</p>
<h2 id="prologue-macro"><a class="header" href="#prologue-macro">Prologue macro</a></h2>
<p>Before using any Lockjaw attribute macros, the
lockjaw <a href="https://docs.rs/lockjaw/latest/lockjaw/macro.prologue.html"><code>prologue!()</code></a> macro must be
called:</p>
<pre><code class="language-rust no_run noplayground">// https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/src/main.rs
</code></pre>
<p>The file path of the current source file should be passed to the prologue.</p>
<p>Lockjaw need to perform some static analysis on the current source file to understand type names,
which is an integral part of a dependency injection framework. If a type is encountered, what is its
fully qualified name? Is it something imported with a <code>use</code> declaration? or if it is a locally
declared, what is the <code>mod</code> path to the local scope?</p>
<p>Lockjaw also generates a test to verify the source path is correct. However passing a wrong path
often result in weird type resolution errors at compile time. Double-check the source path if there
are type resolution issues.</p>
<h2 id="epilogue-macro"><a class="header" href="#epilogue-macro">Epilogue macro</a></h2>
<p>You also must call
the <a href="https://docs.rs/lockjaw/latest/lockjaw/macro.epilogue.html"><code>lockjaw::epilogue!()</code></a> macro in the
root of your crate (<code>lib.rs</code> or
<code>main.rs</code>) after all other uses of lockjaw, preferably at the end of the file.</p>
<pre><code class="language-rust no_run noplayground">// https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/src/main.rs
lockjaw::epilogue!();</code></pre>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/setup/">Source</a> of this chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="injecting-objects"><a class="header" href="#injecting-objects">Injecting Objects</a></h1>
<p>Lockjaw can create objects for you, but you need to let lockjaw know how to create the object and
what is needed to create them. These recipes for object creation is called <em>bindings</em>, which forms
nodes in a dependency graph, and add edges to other bindings it depends on.</p>
<p>The most simple binding is constructor injection binding.</p>
<h2 id="constructor-injection"><a class="header" href="#constructor-injection">Constructor injection</a></h2>
<p>A binding can be created for a struct by using a constructor method, which is a static method
associated to the struct that returns a new instance. The field constructor ( <code>Foo {a : 0, ...}</code>) is
not directly used by Lockjaw since methods are more expressive when a none injected field needs a
default value or when transformations are needed on the input.</p>
<p>A struct can be made injectable by marking a struct <code>impl</code> block with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.injectable.html"><code>#[injectable]</code></a> attribute, and
then mark the constructor method
as <a href="https://docs.rs/lockjaw/latest/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a>.</p>
<pre><code class="language-rust no_run noplayground">struct Foo {}

#[injectable]
impl Foo {
    #[inject]
    pub fn new() -&gt; Foo {
        Foo {}
    }
}</code></pre>
<p>Now Lockjaw understands when trying to create <code>Foo</code>, it should call <code>Foo::new()</code>.</p>
<p>Note that since it is an associated method, constructor injection only works on a type you <em>own</em> (
you can actually change its implementation). For foreign types like imported crates a different
method will be discussed in the <a href="provides.html">providing objects</a> chapter.</p>
<h2 id="constructor-dependencies"><a class="header" href="#constructor-dependencies">Constructor dependencies</a></h2>
<p>To create an object, it may many need objects of other types. This is called <em>dependencies</em>. In this
example, <code>Bar</code> <em>depends</em> on having an instance of <code>Foo</code> to be created.</p>
<p>In constructor injections, dependencies are listed with its parameters. Lockjaw will try to use
available bindings to create all arguments and pass them to the constructor. If a parameter does not
have a binding, Lockjaw will fail compilation with <em>missing bindings</em>.</p>
<p>Note that since we are not asking Lockjaw to actually create the object yet, binding validation
won't be performed. Lockjaw is assuming there are some bindings else where it does not know about
yet.</p>
<pre><code class="language-rust no_run noplayground">struct Bar {
    foo: Foo,
    i: i32,
}

#[injectable]
impl Bar {
    #[inject]
    pub fn new(foo: Foo) -&gt; Bar {
        Bar { foo, i: 42 }
    }
}</code></pre>
<p>If the struct has other fields that can be initialized without injection, like <code>i</code>, it can be
directly assigned. If the object needs a runtime value (for example, if <code>i</code> needs to be assigned by
the caller with a user input), then <a href="factory.html">factories</a> will be needed, which will be discussed
later.</p>
<h2 id="manual-injection"><a class="header" href="#manual-injection">Manual injection</a></h2>
<p>For a moment let's forget about Lockjaw, and try to do dependency injection manually. With the
binding information we have we can write a factory that can create the objects we just defined:</p>
<pre><code class="language-rust no_run noplayground">struct Factory {}

impl Factory {
    pub fn create_foo(&amp;self) -&gt; Foo {
        Foo::new()
    }

    pub fn create_bar(&amp;self) -&gt; Bar {
        Bar::new(self.create_foo())
    }
}

#[test]
fn test() {
    let factory = Factory {};

    let _foo = factory.create_foo();
    let _bar = factory.create_bar();
}</code></pre>
<p>Note that there is one method for each binding, only taking <code>&amp;self</code> and returning the binding type.
Inside the method it calls the constructor method we just marked, and calls other binding methods to
generate the argument.</p>
<p>The factory is an object instead of just methods, since it might need to carry states in the future
(For example, returning a reference to a shared object owned by the factory.)</p>
<p>Writing the factory by hand gets complicated and boring fast. In the next chapter we will ask
Lockjaw to generate it.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/inject/">Source</a> of this chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requesting-objects"><a class="header" href="#requesting-objects">Requesting objects</a></h1>
<p>In the last chapter we manually wrote an object factory:</p>
<pre><code class="language-rust no_run noplayground">struct Factory {}

impl Factory {
    pub fn create_foo(&amp;self) -&gt; Foo {
        Foo::new()
    }

    pub fn create_bar(&amp;self) -&gt; Bar {
        Bar::new(self.create_foo())
    }
}

#[test]
fn test() {
    let factory = Factory {};

    let _foo = factory.create_foo();
    let _bar = factory.create_bar();
}</code></pre>
<p>Now we will ask Lockjaw to automatically generate it. A factory generating objects using a certain
dependency graph is called a <code>Component</code> in Dagger terminology.</p>
<h2 id="defining-the-component"><a class="header" href="#defining-the-component">Defining the component</a></h2>
<pre><code class="language-rust no_run noplayground">#[component]
trait MyComponent {
    fn create_foo(&amp;self) -&gt; Foo;

    fn create_bar(&amp;self) -&gt; Bar;
}</code></pre>
<p>Comparing to the manual factory there are not a lot of changes. Since Lockjaw Cannot generate the
implementation immediately, we use a <code>trait</code> instead of a <code>struct</code> as the interface has to be
abstract. The <code>trait</code> is then annotated with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html"><code>#[component]</code></a> attribute that
instructs Lockjaw to generate the implementation. Lockjaw is able to identify
all <a href="https://docs.rs/lockjaw/latest/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a>
bindings automatically.</p>
<p>For every type we wish to be able to directly create from the component, a method returning the type
should be added to the <code>trait</code>. Like the manual factory, the method should take <code>&amp;self</code> (and nothing
else) so it may further use the component to create the dependencies it needs. The name of the
method does not really matter, but since you are going to call it later you'd probably want
something sensible.</p>
<p>Note that if a type is not directly needed, the <code>trait</code> does not need a method for it. For example
while <code>Bar</code> needs <code>Foo</code>, if we are never going to use <code>Foo</code> in <code>main()</code> we can delete the
<code>create_foo()</code> method. The trait methods does not affect Lockjaw internal generation, it only
declares what needs to be publicly provided.</p>
<h2 id="creating-and-using-the-component"><a class="header" href="#creating-and-using-the-component">Creating and using the component.</a></h2>
<p>Since <code>create_foo(&amp;self)</code> is a method, we need to create the component to be able to call it.
Lockjaw generates a static <code>build()</code> method on the trait that can be used to create the component.</p>
<pre><code class="language-rust no_run noplayground">#[test]
fn test() {
    let component: Box&lt;dyn MyComponent&gt; = &lt;dyn MyComponent&gt;::build();

    let _foo = component.create_foo();
    let _bar = component.create_bar();
}</code></pre>
<p><code>build()</code> returns <code>Box&lt;dyn COMPONENT&gt;</code>. Most IDE today does not understand symbols generated by
procedural macros, so you might want to manually hint the type in the <code>let</code> expression.</p>
<p>Once the component is created, the trait methods can be used to create the objects.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/request/">Source</a> of this
chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="providing-objects"><a class="header" href="#providing-objects">Providing Objects</a></h2>
<p>In this chapter we will discuss another way to create bindings.</p>
<h2 id="limitations-of-constructor-injection-bindings"><a class="header" href="#limitations-of-constructor-injection-bindings">Limitations of constructor injection bindings</a></h2>
<p>Constructor injections are designed to be the <strong>only</strong> way to create an instance of the type it
binds. It is even considered bad practice to call the constructor manually. Hence, constructor
injections has some limitations:</p>
<ul>
<li>Constructor injections can only be done by owned types (can only be defined by the <code>mod</code> that
defines the type itself.).
<ul>
<li>If you don't own the type you should not say something is the only way to create it.</li>
</ul>
</li>
<li>Can only create concrete types
<ul>
<li>Sometimes you may want to bind traits and swap the implementation, maybe at runtime.</li>
</ul>
</li>
</ul>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Obviously Lockjaw is not going to ask the world to use it or the user to rewrite everything they use
with it, so it gives other ways to bind types. Since these bindings are no longer the "one true way
to create things", and different bindings for the same type may be needed within the same program,
the user needs to be able to select which bindings to use in each dependency graph.</p>
<p>In Lockjaw, these elective bindings are defined in <em>modules</em>, and the component can choose what
modules to <em>install</em>, which imports its bindings. Note that in Lockjaw documentation <em>modules</em>
always refer dependency injection modules, and <code>mod</code> will be used to refer to Rust modules.</p>
<p>To declare a module with Lockjaw
the <a href="file:///C:/git/lockjaw/target/doc/lockjaw/attr.module.html"><code>#[module]</code></a> attribute should be
used to mark the <code>impl</code> block of a struct.</p>
<pre><code class="language-rust no_run noplayground">struct MyModule {}

#[module]
impl My Module {
  ...
}</code></pre>
<p>The <code>impl</code> block will contain the binding definitions.</p>
<p>For now the modules should be static (without fields). Modules with fields will be discussed
in <a href="builder.html">builder modules</a></p>
<h2 id="provides-bindings"><a class="header" href="#provides-bindings">#[provides] bindings</a></h2>
<p>The <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a>
binding annotates a method that returns the type.</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    pub fn provide_i32() -&gt; i32 {
        42
    }</code></pre>
<p>Like <a href="https://docs.rs/lockjaw/latest/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a>,
the <code>#[provides]</code> method can also request other bindings from the dependency graph, and produce the
target value with it.</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    pub fn provides_string(i: i32) -&gt; String {
        format!("{}", i)
    }</code></pre>
<h2 id="installing-modules"><a class="header" href="#installing-modules">Installing modules</a></h2>
<p><code>#[module]</code> on its own is just a collection of bindings and does not do anything. It must be
installed in a <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html"><code>#[component]</code></a> to joint
the dependency graph. This is done by listing the module type in
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html#modules"><code>modules</code> metadata</a> of the
component.</p>
<pre><code class="language-rust no_run noplayground">#[component(modules: [MyModule])]
trait MyComponent {
    fn i32(&amp;self) -&gt; i32;

    fn string(&amp;self) -&gt; String;
}</code></pre>
<p>A lot of Lockjaw attribute macros also takes <em>metadata arguments</em>, which is comma
separated <code>key : value</code> pairs in a parenthesis. The values are usually string literal, integers,
types, arrays of values (<code>foo : [value 1, value 2]</code>), or more metadata (<code>foo : { key : value }</code>). In
this case <code>modules</code> takes an array of types (of <code>#[modules]</code>).</p>
<p>Providing <code>trait</code> is a bit more complicated and will be discussed <a href="binds.html">later</a>.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/provide/">Source</a> of this
chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builder-modules"><a class="header" href="#builder-modules">Builder Modules</a></h1>
<p>In the previous chapter the modules are without fields, so Lockjaw can easily create instances of it
(In fact no instance are created since Lockjaw can just call the static methods). However sometimes
we want to be able to affect the values that are bound at runtime, hence need to be able to change
what <code>#[provides]</code> does using fields in the module.</p>
<pre><code class="language-rust no_run noplayground">struct MyModule {
    i: i32,
}

#[module]
impl MyModule {
    #[provides]
    pub fn provide_i32(&amp;self) -&gt; i32 {
        self.i
    }
}</code></pre>
<p>Since the <code>struct</code> now has fields Lockjaw can no longer automatically create it, the user must
manually pass in the modules when creating the component.</p>
<p><em>Implementation note: While Lockjaw can also try to
use <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a> or some other mechanisms,
usages like this implies the module has mutable state and generally is a bad idea.</em></p>
<h2 id="using-builder-modules"><a class="header" href="#using-builder-modules">Using builder modules</a></h2>
<p>Instead of passing the runtime modules to the component one by one, they are collected in a single
<code>struct</code> annotated by
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.builder_modules.html"><code>#[builder_modules]</code></a>
attribute.</p>
<pre><code class="language-rust no_run noplayground">#[builder_modules]
struct MyBuilderModules {
    my_module: MyModule,
}</code></pre>
<p>Every field in the struct should be a module. Using a <code>struct</code> makes sure each module will be
required by the compiler/IDE while exposing the least amount of generated code(which is harder for
users and IDEs to understand, it is better to spell everything out in visible code.).</p>
<p>The <code>#[builder_modules]</code> can then be installed in the component using
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html#builder_modules"><code>builder_modules</code> metadata</a></p>
<pre><code class="language-rust no_run noplayground">#[component(builder_modules: MyBuilderModules)]
trait MyComponent {
    fn i32(&amp;self) -&gt; i32;
}</code></pre>
<p>The component only accepts one<code>#[builder_modules]</code>, which is likely to be specifically tailored for
the component. The modules itself can be shared.</p>
<p>The <code>builder_modules</code> metadata can be used at the same time with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html#modules"><code>modules</code> metadata</a>.
<code>modules</code> should be preferred whenever possible as they are easier to use.</p>
<h2 id="creating-components-with-builder-modules"><a class="header" href="#creating-components-with-builder-modules">Creating components with builder modules</a></h2>
<p>If
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html#builder_modules"><code>builder_modules</code> metadata</a>
is specified,
the  <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.builder_modules.html"><code>#[builder_modules] struct</code></a>
will become the parameter for
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html#component-builder"><code>build()</code> method</a>
of the component which the user must pass.</p>
<pre><code class="language-rust no_run noplayground">#[test]
fn test() {
    let my_module = MyModule { i: 42 };
    let my_builder_modules = MyBuilderModules { my_module };
    let component: Box&lt;dyn MyComponent&gt; = &lt;dyn MyComponent&gt;::build(my_builder_modules);
    assert_eq!(component.i32(), 42);

    let other_component: Box&lt;dyn MyComponent&gt; = &lt;dyn MyComponent&gt;::build(MyBuilderModules {
        my_module: MyModule { i: 123 },
    });
    assert_eq!(other_component.i32(), 123);
}</code></pre>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/builder/">Source</a> of this
chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-traits"><a class="header" href="#binding-traits">Binding traits</a></h1>
<h2 id="provides-trait"><a class="header" href="#provides-trait"><code>#[provides]</code> trait</a></h2>
<p>A <code>trait</code> can be provided using
the <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a>
binding.</p>
<pre><code class="language-rust no_run noplayground">    #[provides]
    pub fn provide_i32_maker(impl_: I32MakerImpl) -&gt; Box&lt;dyn I32Maker&gt; {
        Box::new(impl_)
    }</code></pre>
<p>However, Lockjaw is going to be particular when trying to request a trait object from the dependency
graph. The concrete implementation of the trait may contain <a href="scoped.html">reference to the component</a>,
but ideally this is not something the consumer of the trait should care about, so Lockjaw enforces
that any trait it provides must not outlive the component. The worst case <code>'ComponentLifetime</code> is
assumed, so consumers don't have to change when it actually happens.</p>
<p>The <code>Box</code> returned by the component must be bound by the component's lifetime(same as <code>self</code>).</p>
<pre><code class="language-rust no_run noplayground">#[component(modules: [MyModule])]
trait ProvideComponent {
    fn i32_maker(&amp;'_ self) -&gt; Box&lt;dyn I32Maker + '_&gt;;
}</code></pre>
<h2 id="binds-trait"><a class="header" href="#binds-trait"><code>#[binds]</code> trait</a></h2>
<p>While <code>#[provides]</code> kind of works, binding an implementation to a <code>trait</code> interface is a common
operation so Lockjaw has
the <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.binds.html"><code>#[binds]</code></a> attribute
to make them easier to use.</p>
<p>For an interface and an implementation:</p>
<pre><code class="language-rust no_run noplayground">pub trait Logger {
    fn log(&amp;self, msg: &amp;str);
}

struct StdoutLogger;

#[injectable]
impl StdoutLogger {
    #[inject]
    pub fn new() -&gt; StdoutLogger {
        StdoutLogger
    }
}

impl Logger for StdoutLogger {
    fn log(&amp;self, msg: &amp;str) {
        println!("{}", msg);
    }
}</code></pre>
<p><code>#[binds]</code> can be used to create binding that says "when the <code>Logger</code> interface is needed,
use <code>StdoutLogger</code> as the actual implementation":</p>
<pre><code class="language-rust no_run noplayground">    #[binds]
    pub fn bind_stdout_logger(_impl: StdoutLogger) -&gt; Cl&lt;dyn Logger&gt; {}</code></pre>
<p>The method body must be empty, as Lockjaw will replace it.</p>
<p>The<a href="https://docs.rs/lockjaw/latest/lockjaw/enum.Cl.html"><code>Cl</code></a> in the return type means
<strong>C</strong>omponent <strong>l</strong>ifetimed, which is a wrapper around a type forcing it not outlive the component.
Having this wrapper makes it easier for the compiler to deduce the lifetime.</p>
<p>With the binding defined the <code>Logger</code> can now be used by other classes, without caring about the
actual implementation.</p>
<pre><code class="language-rust no_run noplayground">pub struct Greeter&lt;'component&gt; {
    logger: Cl&lt;'component, dyn Logger&gt;,
}

#[injectable]
impl Greeter&lt;'_&gt; {
    #[inject]
    pub fn new(logger: Cl&lt;dyn Logger&gt;) -&gt; Greeter {
        Greeter { logger }
    }

    pub fn greet(&amp;self) {
        self.logger.log("helloworld!");
    }
}</code></pre>
<p>Note that <code>Logger</code> still has to be injected as <code>Cl&lt;dyn Logger&gt;</code>, and <code>Greeter</code> is also bound by the
lifetime of the component.</p>
<h2 id="unit-testing-with-dependency-injection"><a class="header" href="#unit-testing-with-dependency-injection">Unit testing with dependency injection</a></h2>
<p><code>StdoutLogger</code> writes its output straight to the console, so it is hard to verify <code>Greeter</code> actually
sends the correct thing. While we can give <code>StdoutLogger</code> special apis to memorize what it logs and
give access to tests, having test code in prod is generally bad practice.</p>
<p>Instead we can use dependency injection to replace the environment <code>Greeter</code> runs in. We can create
a <code>TestLogger</code> that writes the logs to memory and can read it later, bind it to the <code>Logger</code> with a
module, and install the module in a component for test that has all test bindings. We are than able
to test <code>Greeter</code> without adding test code to the <code>Greeter</code> itself:</p>
<pre><code class="language-rust no_run noplayground">#[cfg(test)]
pub mod testing {
    use crate::{Greeter, Logger};
    use lockjaw::{component, injectable, module, Cl};

    static mut MESSAGES: Vec&lt;String&gt; = Vec::new();

    pub struct TestLogger;

    #[injectable]
    impl TestLogger {
        #[inject]
        pub fn new() -&gt; TestLogger {
            TestLogger
        }

        pub fn get_messages(&amp;self) -&gt; Vec&lt;String&gt; {
            unsafe { MESSAGES.clone() }
        }
    }

    impl Logger for TestLogger {
        fn log(&amp;self, msg: &amp;str) {
            unsafe { MESSAGES.push(msg.to_owned()) }
        }
    }

    pub struct TestModule;

    #[module]
    impl TestModule {
        #[binds]
        pub fn bind_test_logger(_impl: TestLogger) -&gt; Cl&lt;dyn Logger&gt; {}
    }

    #[component(modules: [TestModule])]
    pub trait TestComponent {
        fn greeter(&amp;self) -&gt; Greeter;
        fn test_logger(&amp;self) -&gt; TestLogger;
    }

    #[test]
    fn test() {
        let component: Box&lt;dyn TestComponent&gt; = &lt;dyn TestComponent&gt;::build();

        component.greeter().greet();

        assert_eq!(
            component.test_logger().get_messages(),
            vec!["helloworld!".to_owned()]
        );
    }
}
</code></pre>
<p>Generally, a library should also provide a test implementation and a module that binds the test
implementation. The consumer of the library can then test by installing the test module instead of
the real module. This allows test infrastructure to easily be shared. Some kind of test scaffolding
can also be created to auto generate the component and inject objects into tests, but that is out of
scope for lockjaw itself.</p>
<p>Note that in the <code>TestLogger</code> <code>MESSAGES</code> is a static mutable, since <code>log()</code> and <code>get_messages()</code> is
going to be called on different instances of <code>TestLogger</code>. This is <code>unsafe</code> and bad, so in the next
chapter we will discuss how to handle this by forcing a single instance of <code>TestLogger</code> to be shared
among everything that uses it.</p>
<p><a href="https://github.com/azureblaze/lockjaw/tree/main/userguide/projects/binds/">Source</a> of this chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-bindings"><a class="header" href="#scoped-bindings">Scoped Bindings</a></h1>
<p>By default everytime a dependency needs to be satisfied, lockjaw creates a new instance, and move it
to the dependency (field or method parameter). This is not always desired since an object may be
used to carry some common state, and we want every type that depends on it to get a reference to a
single instance instead (singletons).</p>
<p>In the last chapter, we had to use a mutable static state to store the messages <code>TestLogger</code> logs,
since we need to read the same messages later but a different instance of <code>TestLogger</code> will be
created.</p>
<p>To do this, the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.injectable.html#scope"><code>scope</code> metadata</a>
can be specified on a <code>#[injecatable]</code> or <code>#[provides]</code>
, passing a component's path. This means there are only one instance of the type for objects created
by the same instance of component (they are not global singletons, you can still have multiple
instances if you have multiple components).</p>
<pre><code class="language-rust no_run noplayground">    #[derive(Default)]
    pub struct TestLogger {
        messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    #[injectable(scope: TestComponent)]
    impl TestLogger {
        #[inject]
        pub fn new() -&gt; TestLogger {
            TestLogger::default()
        }

        pub fn get_messages(&amp;self) -&gt; Vec&lt;String&gt; {
            self.messages.borrow().clone()
        }
    }

    impl Logger for TestLogger {
        fn log(&amp;self, msg: &amp;str) {
            self.messages.borrow_mut().push(msg.to_owned())
        }
    }
</code></pre>
<p>Other types can depend on a scoped type as a reference (<code>&amp;T</code>) or <code>Cl&lt;T&gt;</code></p>
<pre><code class="language-rust no_run noplayground">        fn test_logger(&amp;self) -&gt; Cl&lt;TestLogger&gt;;
    }

    #[test]
    fn test() {
        let component: Box&lt;dyn TestComponent&gt; = &lt;dyn TestComponent&gt;::build();

        component.greeter().greet();

        assert_eq!(
            component.test_logger().get_messages(),
            vec!["helloworld!".to_owned()]
        );
    }
}

epilogue!();</code></pre>
<p>Although <code>#[binds]</code> has to explicitly ask for <code>&amp;TestLogger</code></p>
<pre><code class="language-rust no_run noplayground">        #[binds]
        pub fn bind_test_logger(_impl: &amp;TestLogger) -&gt; Cl&lt;dyn Logger&gt; {}</code></pre>
<p>Note that <code>Greeter</code> hasn't changed at
all. <a href="https://docs.rs/lockjaw/latest/lockjaw/enum.Cl.html"><code>Cl&lt;T&gt;</code></a> allows a type to decouple itself
from whether the type depended on is scoped or not. It may be an owned instance or a shared
instance, but the type does not care as it will not try to move it.</p>
<h2 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h2>
<p>Scoped objects are owned by the component and has the same lifetime as it.</p>
<h2 id="handling-mutability"><a class="header" href="#handling-mutability">Handling mutability</a></h2>
<p>In most uses a scoped type probably should be mutable to make it useful. However we cannot request
it as <code>&amp;mut T</code> since certainly multiple objects will try to request it. Scoped types must
implement <a href="https://doc.rust-lang.org/reference/interior-mutability.html">interior mutability</a> itself
and use an immutable interface. In the example <code>TestLogger</code> use
a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> so the messages can be mutated
even when the <code>TestLogger</code> itself is immutable.</p>
<p>Sometimes it might be easier to wrap the whole class in a memory container like a <code>RefCell</code>
or <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>.
The <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.injectable.html#container"><code>container</code> metadata</a>
can be used on a <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.injectable.html"><code>#[injectable]</code></a> to
bind the type as <code>&amp;CONTAINER&lt;T&gt;</code> instead of <code>&amp;T</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qualifiers"><a class="header" href="#qualifiers">Qualifiers</a></h1>
<p>Sometimes users may need multiple shared instances of the same type for different purposes. For
example the application may need
different <a href="https://docs.rs/futures/0.3.16/futures/executor/struct.ThreadPool.html"><code>ThreadPool</code></a>:</p>
<ul>
<li>A thread pool for UI with a single thread, since OpenGL does not like concurrency.</li>
<li>A thread pool for general purpose CPU bound tasks, with a thread for each physical core.</li>
<li>A thread pool for IO bound tasks, with a small amount of threads. It is IO bound so more threads
won't make it faster</li>
<li>A thread pool for other blocking tasks with unbounded threads. Most of them will be idling anyway.</li>
</ul>
<p>They all share the same type/interface, but have different internal characteristics. Trying to bind
them all will cause duplicated binding failures. Furthermore, the user need to be able to specify
which one they want.</p>
<h2 id="new-type-idiom"><a class="header" href="#new-type-idiom">New type idiom</a></h2>
<p>In most cases,
the <a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html#new-type-idiom">new type idiom</a>
is preferred. With new types, Lockjaw sees them as unrelated and won't cause duplicated binding
issues. The compiler also provides strong compile time type check to ensure the correct one is used
(an API that do IO work can explicitly ask for the IoThreadPool).</p>
<p>However, the new type idiom does not work with bindings with type generated by Lockjaw such
as <a href="provider.html">providers</a>, <a href="optional.html">optional bindings</a>,
and <a href="multibindings.html">multibinding containers</a>. It may also cause a lot of wrapping/unwrapping when
working with third party libraries.</p>
<h2 id="qualifiers-1"><a class="header" href="#qualifiers-1">Qualifiers</a></h2>
<p>Qualifiers are hints for Lockjaw to give a type different tags, so they can be bound separately.</p>
<p>A qualifier must be declared first using
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.qualifier.html"><code>#[qualifier]</code></a> attribute macro.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_qualifier.rs:decl}}</code></pre>
<p>The struct body does not matter and probably should be empty.</p>
<p>Once the qualifier is declared, it can then be used in
the <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.qualified.html"><code>#[qualified]</code></a>
attribute on a method in a <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.module.html"><code>#[module]</code></a>,
marking the return type as qualified. Lockjaw will treat the bindings as distinct types.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_qualifier.rs:module}}</code></pre>
<p>Qualified types can be injected using
the <a href="https://docs.rs/lockjaw/latest/lockjaw/component_attributes/attr.qualified.html"><code>#[qualified]</code></a>
attribute on the parameter, or the component method.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_qualifier.rs:component}}</code></pre>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/injectable_inject_qualified.rs:qualified}}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="providert"><a class="header" href="#providert"><code>Provider&lt;T&gt;</code></a></h1>
<p>Normally when injecting a dependency, <em>one</em> instance of the dependency is <em>created before</em> creating
the depending object. This may not be ideal since the depending object might:</p>
<ul>
<li>Want multiple instance of the object, for example, populating an array.</li>
<li>Have cyclic dependency at <strong>runtime</strong></li>
</ul>
<p>For every binding <code>T</code>, Lockjaw also automatically creates a binding
to <a href="https://docs.rs/lockjaw/latest/lockjaw/struct.Provider.html"><code>Provider&lt;T&gt;</code></a>, which creates a new
instance of <code>T</code>
everytime <a href="https://docs.rs/lockjaw/latest/lockjaw/struct.Provider.html#method.get"><code>get()</code></a>  is
called.</p>
<p>Since a <code>Provider</code> needs to use the component to create the instance, its lifetime is bound by the
component.</p>
<h2 id="creating-multiple-instances"><a class="header" href="#creating-multiple-instances">Creating multiple instances</a></h2>
<p><code>Provider&lt;T&gt;</code> can be used to create instances on request.</p>
<pre><code class="language-rust no_run noplayground">struct Foo {
  bar_provider: Provider&lt;Bar&gt;,
  bars : Vec&lt;Bar&gt;,
}

impl Foo{
    #[inject]
    pub fn new(bar_provider: Provider&lt;Bar&gt;) -&gt; Foo {
      bar_provider,
      bars: vec![bar_provider.get(), bar_provider.get(), bar_provider.get()],
    }
    
    pub fn add_more_bar(&amp;mut self){
       self.bars.push(self.bar_provider.get())
    }
}</code></pre>
<h2 id="bypassing-runtime-cyclic-dependency"><a class="header" href="#bypassing-runtime-cyclic-dependency">Bypassing runtime cyclic dependency</a></h2>
<p>Since regular dependencies must be created before instantiating an object, cyclic dependencies will
result in a recursive stack overflow when the constructor is called. Lockjaw will detect this
situation and refuse to compile your project.</p>
<p>However sometimes the dependency is only used at runtime, not at object construction. This is
especially common when singleton classes need to refer to each other. By using
<code>Provider&lt;T&gt;</code> the cycle can be broken.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/provider_cyclic.rs:cyclic}}</code></pre>
<p>In this example, while instantiating <code>Bar</code>, instantiates a <code>Foo</code>, <code>Bar</code> won't be created
until <code>Foo.create_bar()</code> is called, hence creating either won't trigger a stack overflow.</p>
<p>Trying to call <code>Provider.get</code> may still lead to a stack overflow, and Lockjaw cannot check this for
you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy"><a class="header" href="#lazy">Lazy</a></h1>
<p><a href="https://docs.rs/lockjaw/latest/lockjaw/struct.Lazy.html"><code>Lazy&lt;T&gt;</code></a> is a wrapper around
a <a href="https://docs.rs/lockjaw/latest/lockjaw/struct.Provider.html"><code>Provider&lt;T&gt;</code></a>, which creates the
object once and caches the result. The object will only be created
when <a href="https://docs.rs/lockjaw/latest/lockjaw/struct.Lazy.html#method.get"><code>get()</code></a> is called, and
subsequent invocations returns a reference to the same object.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/lazy.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory"><a class="header" href="#factory">Factory</a></h1>
<p>Sometimes an object needs not only injected values but also runtime values to be created, such as
constructor parameters that depends on user input.</p>
<p>This can be handled by writing a factory that injects bindings as a <a href="provider.html">Provider</a>, and
combine it with the runtime value to create the object. For example,</p>
<pre><code class="language-rust no_run noplayground">pub struct Foo {
    pub i: i32, // runtime
    pub s: String, // injected
}

pub struct FooFactory&lt;'component&gt;{
    s_provider: Provider&lt;'component, String&gt;
}

#[injectable]
impl FooFacotory&lt;'_&gt; {
    #[inject]
    pub fn new(s_provider: Provider&lt;String&gt;) -&gt; FooFactory {
       FooFactory { s_provider }
    }
    
    pub fn create(&amp;self, i: i32) -&gt; Foo {
       Foo { i, s : self.s_provider.get() }
    }
}</code></pre>
<p>This is a lot of boilerplate, and can be automated by
using <a href="https://docs.rs/lockjaw/latest/lockjaw/injectable_attributes/attr.factory.html"><code>#[factory]</code></a>
instead
of <a href="https://docs.rs/lockjaw/latest/lockjaw/injectable_attributes/attr.inject.html"><code>#[inject]</code></a></p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/injectable_factory.rs:factory}}</code></pre>
<p>Runtime parameters needs to be marked with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/injectable_attributes/attr.factory.html#runtime"><code>#[runtime]</code></a>
attribute.</p>
<p><code>FooFactory</code> will be created by Lockjaw, with a method with the same name as the marked method
taking only runtime parameters.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/injectable_factory.rs:factory_use}}</code></pre>
<h2 id="factory-traits"><a class="header" href="#factory-traits">Factory traits</a></h2>
<p>The factory can also be instructed to implement a <code>trait</code> by using the
<a href="https://docs.rs/lockjaw/latest/lockjaw/injectable_attributes/attr.factory.html#implementing"><code>implementing</code> metadata</a>
.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/injectable_factory_implementing.rs:factory}}</code></pre>
<p>The method name and runtime signature must match the <code>trait</code> method the factory should override.</p>
<p>This is especially useful to bind the factory to a trait</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/injectable_factory_implementing.rs:bind}}</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/injectable_factory.rs
https://github.com/azureblaze/lockjaw/blob/main/tests/injectable_factory_implementing.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optional-bindings"><a class="header" href="#optional-bindings">Optional bindings</a></h1>
<p>Sometimes a binding might be optional, being behind
a <a href="https://doc.rust-lang.org/cargo/reference/features.html">cargo feature</a> or provided by an
optional library. It will be useful to allow such bindings to be missing from the dependency graph,
and detect whether such binding exists.</p>
<p>In Lockjaw a binding can be declared as optional by using
the <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.binds_option_of.html">#[binds_option_of]</a>
method attribute in a <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.module.html">#[module]</a></p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_binds_option_of.rs:binds}}</code></pre>
<p>The <code>#[binds_option_of]</code> method should take no parameter and return the type <code>T</code> to bind
as <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a>. This does not actually bind
the <code>T</code>.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_binds_option_of.rs:component}}</code></pre>
<p>If <code>T</code> is actually bound somewhere else, injecting <code>Option&lt;T&gt;</code> will result in <code>Some(T)</code>. Otherwise
it will be <code>None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multibinding"><a class="header" href="#multibinding">Multibinding</a></h1>
<p>Multibinding is a special type of binding in Lockjaw that allows duplicated bindings. Instead of
enforcing one binding per type, multibindings gather the bindings into a collection, allowing
"everything implementing a type" to be injected. This is especially useful to build a plugin system
where an unspecified amount of implementations can be handled.</p>
<p>Multibindings comes in 2 flavors, a <a href="vec.html"><code>Vec&lt;T&gt;</code> binding</a> that simply collects everything, and
<a href="map.html"><code>HashMap&lt;K,V&gt;</code> binding</a> where key collisions are checked at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vect-multibindings"><a class="header" href="#vect-multibindings"><code>Vec&lt;T&gt;</code> multibindings</a></h1>
<p>A <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a> or
<a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.binds.html"><code>#[binds]</code></a> binding can
also be marked with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.into_vec.html"><code>#[into_vec]</code></a>
attribute, which means instead of directly binding to <code>T</code>, the binding should be collected into a
<code>Vec&lt;T&gt;</code>.</p>
<p>With the bindings:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_vec.rs:into_vec}}</code></pre>
<p><code>Vec&lt;String&gt;</code> can be injected with the values <code>["string1", "string2"]</code>. This works across all
modules that are installed.</p>
<p><code>#[into_vec]</code> can also be <a href="qualifiers.html"><code>#[qualified]</code></a></p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_vec.rs:qualified}}</code></pre>
<p>Which result in <code>#[qualified(Q)] Vec&lt;String&gt;</code>. Note that the container is qualified instead of the
content.</p>
<p><code>#[into_vec]</code> also works with <a href="binds.html"><code>#[binds]</code></a></p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_vec.rs:binds}}</code></pre>
<p>Which allows <code>Vec&lt;Cl&lt;dyn Foo&gt;&gt;</code> to be injected. This is a common way to implement event callbacks.</p>
<h2 id="providing-multiple-items"><a class="header" href="#providing-multiple-items">Providing multiple items</a></h2>
<p>A method marked
with <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.elements_into_vec.html"><code>#[elements_into_vec]</code></a>
can return <code>Vec&lt;T&gt;</code>, which will get merged with other <code>#[into_vec]</code> and <code>#[elements_into_vec]</code>.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_vec.rs:elements_into_vec}}</code></pre>
<p>This allows multiple bindings to be provided at once. It also allows a binding method to decide not
to provide anything at runtime, by returning an empty <code>Vec</code>.</p>
<h2 id="duplication-behaviors"><a class="header" href="#duplication-behaviors">Duplication behaviors</a></h2>
<p>Lockjaw's <code>#[into_vec]</code> strays from
Dagger's <a href="https://dagger.dev/api/latest/dagger/multibindings/IntoSet.html"><code>@IntoSet</code></a>, as <code>Hash</code>
and <code>Eq</code> are not universally implemented in Rust. This mean the <code>Vec</code> may contain duplicated values.</p>
<p>However, duplicated modules are not allowed by Lockjaw, so each binding method will be called at
most once when generating the <code>Vec</code>.</p>
<p>If deduplication is needed, you can add another provider that does the conversion:</p>
<pre><code class="language-rust no_run noplayground">#[provides]
pub fn vec_string_to_set_string(v: Vec&lt;String&gt;) -&gt; HashSet&lt;String&gt; {
    HashSet::from_iter(v)
}</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/module_provides_into_vec.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmapkv-multibinding"><a class="header" href="#hashmapkv-multibinding"><code>HashMap&lt;K,V&gt;</code> multibinding</a></h1>
<p>Similar to <a href="vec.html"><code>Vec&lt;T&gt; multibinding</code></a>,
a <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.provides.html"><code>#[provides]</code></a> or
<a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.binds.html"><code>#[binds]</code></a> binding can
also be marked with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.into_map.html"><code>#[into_map]</code></a>
attribute, which collects the key-value pair into
a <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a></p>
<p>While a map can be created by multibinding <code>Vec&lt;(K,V)&gt;</code> or some other entry generating mechanisms,
the <code>HashMap&lt;K,V&gt;</code> multibinding has additional compile time checks to make sure there are no key
collisions.</p>
<h2 id="map-keys"><a class="header" href="#map-keys">Map keys</a></h2>
<p>The value type is specified by the binding method return value, but the key type and value needs to
be specified by a metadata in the <code>#[into_map]</code> attribute.</p>
<h3 id="string_key"><a class="header" href="#string_key"><code>string_key</code></a></h3>
<p><code>string_key</code> specifies the map key is
a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>. The value must be a string
literal, lockjaw is unable to resolve more complex compile time constants.</p>
<p>This example binds to <code>HashMap&lt;String,String&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_map.rs:string_key}}</code></pre>
<h3 id="i32_key"><a class="header" href="#i32_key"><code>i32_key</code></a></h3>
<p><code>i32_key</code> specifies the map key is an <code>i32</code>. The value must be an i32 literal, lockjaw is unable to
resolve more complex compile time constants.</p>
<p>This example binds to <code>HashMap&lt;i32,String&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_map.rs:i32_key}}</code></pre>
<p>Other types are not implemented. <code>i32</code> ought to be enough for everyone.</p>
<h3 id="enum_key"><a class="header" href="#enum_key"><code>enum_key</code></a></h3>
<p><code>i32_key</code> specifies the map key is an <code>enum</code>. Since the <code>enum</code> is going to be used as the map key,
it must satisfy the same constraints <code>HashMap</code> gives, which is
implementing <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>
and <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>. It also must be a simple enum with
no fields so Lockjaw knows how to compare them at compile time (meaning comparing the name is
enough).</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_map.rs:enum}}</code></pre>
<p>This example binds to <code>HashMap&lt;E,String&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_map.rs:enum_key}}</code></pre>
<p>Lockjaw is able to infer the enum type (<code>E</code>) if the value is imported (<code>use E::Bar</code>), but the code
maybe be more readable if the type is explicitly spelled out, especially most IDEs today cannot
properly inspect tokens inside the metadata.</p>
<h2 id="qualifiers-2"><a class="header" href="#qualifiers-2">Qualifiers</a></h2>
<p><code>#[into_map]</code> can also be <a href="qualifiers.html"><code>#[qualified]</code></a></p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_provides_into_map.rs:qualified}}</code></pre>
<p>Which result in <code> #[qualified(Q)] HashMap&lt;String, String&gt;</code>. Note that the container is qualified
instead of the content.</p>
<h2 id="dynamic-map-entries"><a class="header" href="#dynamic-map-entries">Dynamic map entries</a></h2>
<p>All bindings in <code>#[into_map]</code> must be resolved at compile time, There are
no <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.elements_into_vec.html"><code>#[elements_into_vec]</code></a>
equivalent such as <code>#[elements_into_map]</code>.</p>
<p>However dynamic map entries can be achieved by rebinding <code>Vec&lt;(K,V)&gt;</code> into a <code>HashMap&lt;K,V&gt;</code>.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/module_provides_into_map.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empty-multibindings"><a class="header" href="#empty-multibindings">Empty multibindings</a></h1>
<p>The binding for <code>Vec&lt;T&gt;</code> and <code>HashMap&lt;K,V&gt;</code> is automatically generated when <a href="vec.html"><code>#[into_vec]</code></a>
or <a href="map.html"><code>#[into_map]</code></a> is encountered. However when such binding does not exist and someone
depended on the collection, Lockjaw cannot be sure if it should provide an empty collection since it
should be a multibinding, or if the user forgot to bind the collection.</p>
<p>This usually happens when a library defines a multibinding for events, etc., but does not bind
anything to it itself, and clients aren't forced to use the event.</p>
<p>A <a href="https://docs.rs/lockjaw/latest/lockjaw/module_attributes/attr.multibinds.html"><code>#[multibinds]</code></a>
method that returns the collection type should be declared in such case, to let Lockjaw know a
multibinding collection is intended, but it may be empty.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_multibinds.rs:multibinds}}</code></pre>
<p><code>#[multibinds]</code> also serves as documentation on the <code>#[module]</code> specifying it is expecting the
multibinding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subcomponents"><a class="header" href="#subcomponents">Subcomponents</a></h1>
<p><a href="scoped.html">Scopes</a> enforces an object to be a singleton within the component, so everyone can
interact with the same instance. However there are times when we need multiple sets of such
instances. For example, we might be implementing a web server, and there are a lot of shared
resources with every session. We want the session to be independent, so we need to create component
for each session:</p>
<pre><code class="language-rust no_run noplayground">impl Server {
    pub fn new_session(url: Url) -&gt; Session {
      Session{
         component: &lt;dyn SessionComponent&gt;::build({url,...})
      }
    }
}</code></pre>
<p>However, there are also some resource that belongs to the whole server shared by all sessions, for
example, an IO bound thread pool. We have to rebind this in every <code>SessionComponent</code></p>
<pre><code class="language-rust no_run noplayground">impl Server{
    #[inject]
    pub fn new(#[qualified(IoBound)] io_threadpool: &amp;ThreadPool) { ... }
    
        pub fn new_session(&amp;self, url: Url) -&gt; Session {
        Session {
            component: &lt;dyn SessionComponent&gt;::build({
                url,
                self.io_threadpool,
                ...
            })
        }
    }
}</code></pre>
<p>Managing these will soon get ugly.</p>
<p>Instead we can create
a <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.subcomponent.html"><code>#[subcomponent]</code></a> which can have
distinct scoped bindings, modules, but also has access to bindings in its parent component.</p>
<p>Using <code>#[subcomponent]</code> is almost identical to a regular <code>#[component]</code>, except that the
<code>#[subcomponent]</code> has to be installed in a parent component, and the method to create an instance.</p>
<h2 id="installing-a-subcomponent"><a class="header" href="#installing-a-subcomponent">Installing a <code>#[subcomponent]</code></a></h2>
<p>A <code>#[subcomponent]</code> is installed by first listing it in
a <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.module.html#"><code>#[module]</code></a> using
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.module.html#subcomponents"><code>subcomponents</code> metadata</a></p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/sub_component.rs:list}}</code></pre>
<p>Then installing the <code>#[module]</code> in a parent component. The parent component can be either a regular
component or another subcomponent.</p>
<h2 id="creating-a-instance-of-the-subcomponent"><a class="header" href="#creating-a-instance-of-the-subcomponent">Creating a instance of the subcomponent</a></h2>
<p>The <code>#[module]</code> with a <code>subcomponents: [FooSubcomponent]</code> metadata creates hidden binding
of <code>Cl&lt;FooSubcomponentBuilder&gt;</code> which can be injected to create new instances of <code>FooSubcomponent</code>
by calling <code>build()</code>. <code>build()</code> also takes the
corresponding <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.builder_modules.html"><code>#[builder_modules]</code></a>
if the subcomponent is defined with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html#builder_modules"><code>builder_modules</code> metadata</a></p>
<p><code>build</code> can be called multiple times to create independent subcomponents, with the parent being
shared.</p>
<h2 id="lifetime-1"><a class="header" href="#lifetime-1">Lifetime</a></h2>
<p>The lifetime of the subcomponent is bound by its parent.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>https://github.com/azureblaze/lockjaw/blob/main/tests/sub_component.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defined-components"><a class="header" href="#defined-components">Defined components</a></h1>
<p>One of the issues with
using <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.component.html#"><code>#[component]</code></a>
and <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.subcomponent.html"><code>#[subcomponent]</code></a> is that
modules still has to be listed, which means anything using the component will depend on everything.
The component is also generated in the crate, so other crates depending on it is not able to expand
the dependency graph, which makes <a href="multibindings.html">multibindings</a> less useful. Additionally, unit
tests often needs a different set of modules, so the whole component has to be redefined.</p>
<p>In a large project there maybe tens and even hundreds of modules, and this will become very
difficult to manage.</p>
<p>Instead of <code>#[component]</code> and <code>#[subcomponent]</code>, Lockjaw also
provides <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.define_component.html"><code>#[define_component]</code></a>
and<a href="https://docs.rs/lockjaw/latest/lockjaw/attr.define_subcomponent.html"><code>#[define_subcomponent]</code></a>
which automatically collects modules from the entire build dependency tree, so they no longer need
to be manually installed.</p>
<h1 id="root-crate"><a class="header" href="#root-crate">Root crate</a></h1>
<p>When using <code>#[define_component]</code> the component is not immediately generated, since modules from
crates depending on the current crate may still want to add to the dependency graph.</p>
<p>Lockjaw needs to know which crate is the root crate that is not depended on by other crates, which
is done by passing
the <a href="https://docs.rs/lockjaw/latest/lockjaw/macro.epilogue.html#root"><code>root</code> identifier</a> to
the <a href="https://docs.rs/lockjaw/latest/lockjaw/macro.epilogue.html"><code>epilogue!()</code> macro</a></p>
<pre><code>epilogue!(root);
</code></pre>
<p>Typically the root crate is the binary. Libraries can also be the root crate but that is probably
not a good idea. Lockjaw will fail compilation if a crate using it depends on another crate that is
a root crate.</p>
<h2 id="automatically-installing-modules"><a class="header" href="#automatically-installing-modules">Automatically installing modules</a></h2>
<p><a href="https://docs.rs/lockjaw/latest/lockjaw/attr.module.html"><code>#[modules]</code></a> can be automatically
installed in a component by using
the <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.module.html#install_in"><code>install_in</code> metadata</a>. The
metadata takes a path to a <code>#[define_component]</code> <code>trait</code>. Alternatively, it can also be a path to
<a href="https://docs.rs/lockjaw/latest/lockjaw/trait.Singleton.html"><code>Singleton</code></a>, which means it should be
installed in every <code>#[define_component]</code> but not <code>#[define_subcomponent]</code>.</p>
<p>Such modules cannot have fields.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/module_install_in.rs:install_in}}</code></pre>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h2>
<p>Ideally a component should only be used at the program's entry point, and rest of the program should
all use dependency injection, instead of trying to pass the component around. However sometimes
callbacks will be called from non-injected context, and the user will need to reach back into the
component.</p>
<p>These kinds of usage will cause the <a href="request.html">requesting methods</a> in a component to bloat, and
add redundant dependencies or cycle issues to everyone that uses the component.</p>
<p>With <code>#[define_component]</code>
, <a href="https://docs.rs/lockjaw/latest/lockjaw/attr.entry_point.html"><code>#[entry_point]</code></a> can be used.</p>
<p>An <code>#[entry_point]</code> has binding requesting methods just like a component.
The <a href=""><code>install_in</code> metadata</a> needs to be used to install the <code>#[entry_point]</code> in a component. Once
installed, the</p>
<pre><code class="language-rust no_run noplayground">&lt;dyn FooEntryPoint&gt;::get(component : &amp;dyn FooComponent) -&gt; &amp;dyn FooEntryPoint</code></pre>
<p>method can be used to cast the opaque component into the entry point, and access the dependency
graph.</p>
<pre><code class="language-rust no_run noplayground">{{#include ../../tests/entry_point.rs:entry_point}}</code></pre>
<h2 id="testing-with-define_component"><a class="header" href="#testing-with-define_component">Testing with <code>#[define_component]</code></a></h2>
<p>While compiling tests, Lockjaw gathers <code>install_in</code> modules only from the <code>[dev-dependencies]</code>
section of <code>Cargo.toml</code> instead of the regular <code>[dependencies]</code>, even though <code>[dev-dependencies]</code>
inherits <code>[dependencies]</code>. This is due to tests often have conflicting modules with prod code. any
prod modules that need to be used in tests has to be relisted again in the <code>[dev-dependencies]</code>
section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caveats"><a class="header" href="#caveats">Caveats</a></h1>
<p>This section discusses the <em>creative solutions</em> Lockjaw used to achieve its goal. They are abhorrent
engineering practices that abuses undocumented behaviors of Rust, and are the main reasons you
should not use Lockjaw in any serious project.</p>
<p>They are documented so maybe someone can come up with a better solution, or Rust can provide new
language features to make Lockjaw usable.</p>
<h2 id="path-resolution"><a class="header" href="#path-resolution"><a href="path_resolution.html">Path resolution</a></a></h2>
<p>Lockjaw need to know the fully qualified path of a type, so they can be compared against each other.</p>
<h2 id="cross-macro-communication"><a class="header" href="#cross-macro-communication"><a href="cross_macro_communication.html">Cross macro communication</a></a></h2>
<p>Lockjaw has seperated declaration phase (what the bindings are) and code generation phase (building
the dependency graph). The generation phase need to know everything the declaration phase has seen.</p>
<h2 id="bypassing-visibility"><a class="header" href="#bypassing-visibility"><a href="visibility_bypass.html">Bypassing visibility</a></a></h2>
<p>A lot of symbols need should be private to the module/crate, but also give an exclusive bypass to
Lockjaw, so it can be used by a component generated elsewhere, possibly a different crate.</p>
<h2 id="late-implementation-generation"><a class="header" href="#late-implementation-generation"><a href="late_impl_generation.html">Late implementation generation</a></a></h2>
<p>Rust only allows <code>impl</code> blocks in the same <code>mod</code> the <code>struct</code> is in. However, some implementations
have to be generated at the <code>mod</code> root or a different crate, where information are more complete.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-resolution-1"><a class="header" href="#path-resolution-1">Path resolution</a></h1>
<p>Lockjaw need to know the fully qualified path of a type, so they can be compared against each other.</p>
<p>In Rust, all a <code>proc_macro</code> can see is tokens, which is too early to resolve the type path. When a
<code>Foo</code> identifier is encountered, it is difficult for the macro to understand whether it is a type
declared in the local module, or a type from somewhere else brought in by a <code>use</code> declaration. Rust
don't even tell the macro what the local module is.</p>
<h2 id="base-mod-of-the-file"><a class="header" href="#base-mod-of-the-file">Base <code>mod</code> of the file</a></h2>
<p>The first problem is the <code>proc_macro</code> doesn't even know where the source being compiled is at. The
<a href="https://doc.rust-lang.org/std/macro.file.html"><code>file!()</code></a>
and <a href="https://doc.rust-lang.org/std/macro.module_path.html"><code>module_path!()</code></a> would be a perfect
solution to this, but <a href="https://github.com/rust-lang/rfcs/pull/2320">eager macro expansion</a> is
required for a <code>proc_macro</code> to be able to utilize it.</p>
<p><a href="https://docs.rs/proc-macro2/1.0.28/proc_macro2/struct.Span.html#method.source_file">proc_macro2::Span::source_file()</a>
also exists, but it is nightly feature and requires <code>procmacro2_semver_exempt</code> which is contagious.</p>
<p>Since the with <a href="cross_macro_communication.html">cross macro communication</a> hacks the user only need to
do this once per file, we've decided to let the user pass the current path with
the <a href="https://docs.rs/lockjaw/latest/lockjaw/macro.prologue.html"><code>prologue!()</code></a> macro. We will need
to parse the whole file later anyway, so we take the file name and derive the <code>mod</code> path from it.</p>
<p>To make sure the <code>prologue!()</code> macro is called in every file, it declares a hidden symbol locally
which all other Lockjaw <code>proc_macro</code> will try to use, so if the <code>prolouge!()</code> is missing compilation
will fail. In later steps we also verify <code>prologue!()</code> is the first Lockjaw macro called in the
file, as the current file info is stored in global memory and must be reset in each file.</p>
<p><code>prolouge!()</code> also generates a test to make sure the path passed in matches what <code>file!()</code> would
give. However using the wrong path will usually cause Lockjaw to fail miserably since all type info
are messed up, and the test will not even be run, which makes it not too useful.</p>
<h2 id="mod-structure-and-use-declarations"><a class="header" href="#mod-structure-and-use-declarations"><code>mod</code> structure and <code>use</code> declarations</a></h2>
<p>A file can still contain nested <code>mod</code> in it, each importing more symbols with the <code>use</code> declaration.
For a given token, lockjaw needs to know which <code>mod</code> it is in, and what symbols are brought into
that scope. This requires parsing the whole file, so we can keep what the span of each <code>mod</code> is and
what <code>use</code> are inside it.</p>
<p><a href="https://docs.rs/syn/1.0.75/syn/fn.parse_file.html"><code>syn::parse_file()</code></a> sounds like a good fit for
this, however the tokens it produces does not record
proper <a href="https://docs.rs/proc-macro2/1.0.28/proc_macro2/struct.Span.html">spans</a>, so we cannot use it
to find the position of <code>mod</code>.</p>
<p>Lockjaw handles this by using another AST
parser (<a href="https://crates.io/crates/tree-sitter">tree_sitter</a>) to parse the file.</p>
<h2 id="finding-which-mod-a-token-is-in"><a class="header" href="#finding-which-mod-a-token-is-in">Finding which <code>mod</code> a token is in</a></h2>
<p>Position info of a token is encoded in
the <a href="https://docs.rs/proc-macro2/1.0.28/proc_macro2/struct.Span.html">span</a> object, but currently it
is opaque. Lockjaw forcefully extract the data from
span's <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> representation, which contains
the token's byte range. No need to say this is an awful thing to do.</p>
<p>Once the byte position is know, it can be used to find the deepest enclosing <code>mod</code>.</p>
<h2 id="handling-file-mod"><a class="header" href="#handling-file-mod">Handling file <code>mod</code></a></h2>
<p>Rust currently handles file <code>mod</code> as includes internally. It inserts the content of the file
directly into the token stream, and ends up in a giant stream for the whole crate. The consequence
of this is the byte position the <code>proc_marco</code> token actually have is shifted around by inserted
files, and will not match its byte position inside the file the 3p AST parser sees.</p>
<p>Fortunately the Lockjaw <code>proc_macro</code> has the span of the <code>prologue!()</code> macro itself, and it knows
the macro must appear only once inside the file. Lockjaw is able to inspect the AST to find the file
position of the <code>prologue!()</code> macro, and calculate the offset between file position and token
position.</p>
<p>One of the effect is Lockjaw has to ban file <code>mod</code> that appears after <code>prologue!()</code>, as it will
invalidate the offset. Theoretically Lockjaw can recursively calculate the size of the file <code>mod</code>,
but limiting the position of file <code>mod</code> does not seem too bad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-macro-communication-1"><a class="header" href="#cross-macro-communication-1">Cross macro communication</a></h1>
<p>Lockjaw <code>proc_macro</code> are not independent, it requires inputs from other macros in strict order:</p>
<ol>
<li>A first pass on the file to <a href="path_resolution.html">generate mod info for path resolution</a></li>
<li>Generating binding definition, with paths resolved to fully qualified path using info from step
1.</li>
<li>Actual generation of the components, after all bindings are defined.</li>
</ol>
<p>Additionally the binding info in step 2. may be needed across crates.</p>
<h2 id="intra-crate-macro-communication"><a class="header" href="#intra-crate-macro-communication">Intra-crate macro communication</a></h2>
<p>Lockjaw macros talk to each other by storing states in a static mutable variable. This requires the
token/macro phase of rust to invoke all macros in a single process, single thread, sequentially as
they appear in the source, as well as expanding file <code>mod</code> in place as soon as they are encountered.</p>
<p>Rust does not have any guarantee when proc_macros are executed, the order they are executed, the
threads they are executed on, or even the process they are executed on. This can easily break if the
compilation mode changes, such as incremental compilation (some proc_marco are not re-invoked) and
multi-threaded compilation.</p>
<p>It would be nice if rust somehow allows proc_macro to generate pieces of serializable metadata that
can be read by other proc_macros.</p>
<h2 id="intra-crate-macro-communication-1"><a class="header" href="#intra-crate-macro-communication-1">Intra-crate macro communication</a></h2>
<p>Lockjaw allows <code>#[inject]</code> in a crate to be used by another crate that depends on it. Additionally
<code>#[denfine_component]</code> allows components to be generated at the root crate, using binding info from
every crate it directly or indirectly depends on. This means a crate must be able to read the
binding metadata of every crate.</p>
<p>Lockjaw handles this by writing the binding metadata of each crate to a file, which other crates can
read. This creates a few issues:</p>
<h3 id="proc_macro-writes-data-to-build-script-out_dir"><a class="header" href="#proc_macro-writes-data-to-build-script-out_dir">proc_macro writes data to build script OUT_DIR</a></h3>
<p>To handle cross-crate dependencies, lockjaw writes the bindings metadata to OUT_DIR so other crates
can read it later.</p>
<p>Rust only specifies the build script should write to OUT_DIR, while proc_macro seems to run on the
same process and has the environment variable (when there is a build script, so lockjaw forces the
user to use a build script even though it is doing nothing).</p>
<h3 id="proc_macro-reads-data-from-disk"><a class="header" href="#proc_macro-reads-data-from-disk">proc_macro reads data from disk</a></h3>
<p>Same as above, lockjaw proc_macro reads data from other crates output so cross-crate dependency
graph can be generated.</p>
<h3 id="proc_macro-writes-data-to-other-crates-out_dir"><a class="header" href="#proc_macro-writes-data-to-other-crates-out_dir">proc_macro writes data to other crate's OUT_DIR</a></h3>
<p>Also for cross-crate dependency, the binding metadata from other crates are required. While lockjaw
can determine the crate's dependencies with <code>cargo tree</code> (proc_macro spawning processes is probably
also a bad idea), it has no idea where their OUT_DIR are.</p>
<p>The current solution is to hardcode the proc_macro library's OUT_DIR into itself with a build
script, and let other crates that uses lockjaw also write their OUT_DIR to the proc_macro library's
OUT_DIR so it can be looked up later. Mutating data outside a crate's bound seems really bad.</p>
<p>This can be solved if:</p>
<ul>
<li>Rust allow looking up OUT_DIR of crates depended on.</li>
<li>Rust allow compile time reflection such as inspecting whether a const string exists and reading
its value, so the metadata can be encoded.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bypassing-visibility-1"><a class="header" href="#bypassing-visibility-1">Bypassing visibility</a></h1>
<p>Visibility control works a bit weird with dependency injection. When a type is private, only context
that have visibility should be able to inject it, but the dependency injection framework should
still be able to construct it, even if the generated code is in some random <code>mod</code>. Currently Rust
only allow visibility bypass to be granted to a <code>mod</code> that is a parent of the current <code>mod</code>.</p>
<p>Lockjaw handles this with
the <a href="https://docs.rs/lockjaw/0.2.1/lockjaw/attr.component_visible.html"><code>#[component_visible]</code></a>
attribute macro. The macro modifies the <code>struct</code> declaration, so it is declared as public with a
hidden name, and then alias the original name with the original visibility. Internally Lockjaw uses
the hidden name. Everything is actually public.</p>
<p>This type of hack is hard to perform on a <code>mod</code>, so every <code>mod</code> that has a binding must be visible
to the crate root (using <code>pub(crate)</code>). Lockjaw then reexport the hidden type as public at the crate
root.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="late-implementation-generation-1"><a class="header" href="#late-implementation-generation-1">Late implementation generation</a></h1>
<p>Rust requires the <code>impl</code> block to appear in the same <code>mod</code> is the type it implements. Items cannot
be added to a mod later either. However with Lockjaw information to generate the implementation may
not be available at the time, especially for component builders. Furthermore, the implementation may
not even be possible in the same crate
for <a href="https://docs.rs/lockjaw/0.2.0/lockjaw/attr.define_component.html"><code>#[define_component]</code></a>.</p>
<p>Component builders should be associated method of the component, or at least a free-standing
function in the same <code>mod</code>. Otherwise it will be hard for users to locate them.</p>
<p>Lockjaw handles this by implementing such methods by calling an <code>extern</code> method. Which will later
be generated. While this works, if the user forgets to call the code generation macro, a cryptic
linker error about missing symbol will appear.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h1>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of
experience, education, socio-economic status, nationality, personal appearance,
race, religion, or sexual identity and orientation.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to creating a positive environment
include:</p>
<ul>
<li>Using welcoming and inclusive language</li>
<li>Being respectful of differing viewpoints and experiences</li>
<li>Gracefully accepting constructive criticism</li>
<li>Focusing on what is best for the community</li>
<li>Showing empathy towards other community members</li>
</ul>
<p>Examples of unacceptable behavior by participants include:</p>
<ul>
<li>The use of sexualized language or imagery and unwelcome sexual attention or
advances</li>
<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or electronic
address, without explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a
professional setting</li>
</ul>
<h2 id="our-responsibilities"><a class="header" href="#our-responsibilities">Our Responsibilities</a></h2>
<p>Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.</p>
<p>Project maintainers have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, or to ban temporarily or permanently any
contributor for other behaviors that they deem inappropriate, threatening,
offensive, or harmful.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.</p>
<p>This Code of Conduct also applies outside the project spaces when the Project
Steward has a reasonable belief that an individual's behavior may have a
negative impact on the project or its community.</p>
<h2 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h2>
<p>We do not believe that all conflict is bad; healthy debate and disagreement
often yield positive results. However, it is never okay to be disrespectful or
to engage in behavior that violates the project’s code of conduct.</p>
<p>If you see someone violating the code of conduct, you are encouraged to address the behavior
directly with those involved. Many issues can be resolved quickly and easily, and this gives people
more control over the outcome of their dispute. If you are unable to resolve the matter for any
reason, or if the behavior is threatening or harassing, report it. We are dedicated to providing an
environment where participants feel welcome and safe.</p>
<p>Reports should be directed to azureblaze, the Project Steward(s) for Lockjaw. It is the Project
Steward’s duty to receive and address reported violations of the code of conduct. They will then
work with a committee consisting of representatives from the Open Source Programs Office and the
Google Open Source Strategy team. If for any reason you are uncomfortable reaching out to the
Project Steward, please email opensource@google.com.</p>
<p>We will investigate every complaint, but you may not receive a direct response. We will use our
discretion in determining when and how to follow up on reported incidents, which may range from not
taking action to permanent expulsion from the project and project-sponsored spaces. We will notify
the accused of the
report and provide them an opportunity to discuss it before any action is taken.
The identity of the reporter will be omitted from the details of the report
supplied to the accused. In potentially harmful situations, such as ongoing
harassment or threats to anyone's safety, we may take action without notice.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4,
available at
https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to Contribute</a></h1>
<p>The Lockjaw project is still very experimental, and may not have enough bandwidth to accept
contributions. However if you still wish to proceed, there are a few small guidelines you need to
follow.</p>
<h2 id="contributor-license-agreement"><a class="header" href="#contributor-license-agreement">Contributor License Agreement</a></h2>
<p>Contributions to this project must be accompanied by a Contributor License Agreement. You (or your
employer) retain the copyright to your contribution; this simply gives us permission to use and
redistribute your contributions as part of the project. Head over
to <a href="https://cla.developers.google.com/">https://cla.developers.google.com/</a> to see your current agreements on file or to sign a new one.</p>
<p>You generally only need to submit a CLA once, so if you've already submitted one
(even if it was for a different project), you probably don't need to do it again.</p>
<h2 id="code-reviews"><a class="header" href="#code-reviews">Code reviews</a></h2>
<p>All submissions, including submissions by project members, require review. We use GitHub pull
requests for this purpose. Consult
<a href="https://help.github.com/articles/about-pull-requests/">GitHub Help</a> for more information on using
pull requests.</p>
<h2 id="community-guidelines"><a class="header" href="#community-guidelines">Community Guidelines</a></h2>
<p>This project follows <a href="https://opensource.google/conduct/">Google's Open Source Community Guidelines</a>
.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
